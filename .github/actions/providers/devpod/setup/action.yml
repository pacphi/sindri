name: Setup DevPod Provider
description: Sets up DevPod with specified cloud provider (AWS, GCP, Azure, DigitalOcean, Kubernetes, SSH)

inputs:
  provider-type:
    description: DevPod provider type (aws, gcp, azure, digitalocean, kubernetes, ssh, docker)
    required: true
  provider-name:
    description: Custom name for provider instance
    required: false
    default: ""
  install-cli:
    description: Whether to install DevPod CLI
    required: false
    default: "true"
  devpod-version:
    description: DevPod CLI version to install
    required: false
    default: "latest"
  provider-options:
    description: JSON object with provider-specific options
    required: false
    default: "{}"

  # AWS-specific inputs
  aws-region:
    description: AWS region for EC2 instances
    required: false
    default: "us-west-2"
  aws-instance-type:
    description: AWS EC2 instance type
    required: false
    default: "c5.xlarge"
  aws-disk-size:
    description: AWS EBS volume size in GB
    required: false
    default: "40"
  aws-use-spot:
    description: Use AWS spot instances
    required: false
    default: "false"

  # GCP-specific inputs
  gcp-project:
    description: GCP project ID
    required: false
    default: ""
  gcp-zone:
    description: GCP zone for instances
    required: false
    default: "us-central1-a"
  gcp-machine-type:
    description: GCP machine type
    required: false
    default: "e2-standard-4"

  # Azure-specific inputs
  azure-subscription:
    description: Azure subscription ID
    required: false
    default: ""
  azure-resource-group:
    description: Azure resource group name
    required: false
    default: "devpod-resources"
  azure-location:
    description: Azure location/region
    required: false
    default: "eastus"
  azure-vm-size:
    description: Azure VM size
    required: false
    default: "Standard_D4s_v3"

  # DigitalOcean-specific inputs
  do-region:
    description: DigitalOcean region
    required: false
    default: "nyc3"
  do-size:
    description: DigitalOcean droplet size
    required: false
    default: "s-4vcpu-8gb"

  # Kubernetes-specific inputs
  k8s-config-path:
    description: Path to kubeconfig file
    required: false
    default: "~/.kube/config"
  k8s-context:
    description: Kubernetes context to use
    required: false
    default: ""
  k8s-namespace:
    description: Kubernetes namespace for DevPod workspaces
    required: false
    default: "devpod"
  k8s-use-local-cluster:
    description: Create a local cluster for testing (auto-detected if KUBECONFIG not provided)
    required: false
    default: "auto"
  k8s-local-cluster-type:
    description: Type of local cluster to create (kind or k3d)
    required: false
    default: "kind"
  k8s-local-cluster-name:
    description: Name for the local cluster
    required: false
    default: "sindri-test"
  k8s-kind-version:
    description: Kind version to install (only used when cluster-type is kind)
    required: false
    default: "v0.27.0"
  k8s-kind-node-image:
    description: Kind node image / Kubernetes version (only used when cluster-type is kind)
    required: false
    default: "kindest/node:v1.32.0"
  k8s-k3d-version:
    description: k3d version to install (only used when cluster-type is k3d)
    required: false
    default: "v5.7.5"
  k8s-k3d-k8s-version:
    description: Kubernetes version for k3d (only used when cluster-type is k3d)
    required: false
    default: "v1.31.4"

  # SSH-specific inputs
  ssh-host:
    description: SSH host address
    required: false
    default: ""
  ssh-user:
    description: SSH username
    required: false
    default: ""
  ssh-key-path:
    description: Path to SSH private key
    required: false
    default: "~/.ssh/id_rsa"

outputs:
  provider-id:
    description: Configured provider identifier
    value: ${{ steps.configure.outputs.provider-id }}
  provider-status:
    description: Provider setup status
    value: ${{ steps.verify.outputs.status }}
  provider-config:
    description: JSON object with provider configuration
    value: ${{ steps.configure.outputs.config }}
  local-cluster-created:
    description: Whether a local cluster was created
    value: ${{ steps.local-cluster.outputs.created }}
  local-cluster-type:
    description: Type of local cluster (kind or k3d)
    value: ${{ steps.local-cluster.outputs.cluster-type }}
  local-cluster-name:
    description: Name of the local cluster (if created)
    value: ${{ steps.local-cluster.outputs.cluster-name }}
  local-registry-url:
    description: URL of the local registry (if local cluster with registry was created)
    value: ${{ steps.local-cluster.outputs.registry-url }}
  local-registry-name:
    description: Name of the local registry container (if created)
    value: ${{ steps.local-cluster.outputs.registry-name }}

runs:
  using: composite
  steps:
    - name: Install DevPod CLI
      if: inputs.install-cli == 'true'
      shell: bash
      run: |
        echo "::group::Installing DevPod CLI"

        # Determine version
        if [[ "${{ inputs.devpod-version }}" == "latest" ]]; then
          VERSION=$(curl -s https://api.github.com/repos/loft-sh/devpod/releases/latest | jq -r .tag_name)
        else
          VERSION="${{ inputs.devpod-version }}"
        fi

        # Determine platform
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)
        if [[ "$ARCH" == "x86_64" ]]; then
          ARCH="amd64"
        elif [[ "$ARCH" == "aarch64" ]]; then
          ARCH="arm64"
        fi

        # Download and install
        DOWNLOAD_URL="https://github.com/loft-sh/devpod/releases/download/${VERSION}/devpod-${OS}-${ARCH}"
        echo "Downloading DevPod from: $DOWNLOAD_URL"

        curl -L -o /tmp/devpod "$DOWNLOAD_URL"
        chmod +x /tmp/devpod
        sudo mv /tmp/devpod /usr/local/bin/devpod

        # Verify installation
        devpod version

        echo "::endgroup::"

    - name: Setup cloud provider CLI tools
      shell: bash
      run: |
        echo "::group::Setting up provider CLI tools"

        case "${{ inputs.provider-type }}" in
          aws)
            # Install AWS CLI if not present
            if ! command -v aws &> /dev/null; then
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install
              rm -rf aws awscliv2.zip
            fi
            ;;

          gcp)
            # Install gcloud CLI if not present
            if ! command -v gcloud &> /dev/null; then
              echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | \
                sudo tee -a /etc/apt/sources.list.d/google-cloud-sdk.list
              curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | \
                sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
              sudo apt-get update && sudo apt-get install -y google-cloud-cli
            fi
            ;;

          azure)
            # Install Azure CLI if not present
            if ! command -v az &> /dev/null; then
              curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
            fi
            ;;

          digitalocean)
            # Install doctl if not present
            if ! command -v doctl &> /dev/null; then
              cd /tmp
              wget https://github.com/digitalocean/doctl/releases/latest/download/doctl-$(uname -s)-$(uname -m).tar.gz
              tar xf doctl-*.tar.gz
              sudo mv doctl /usr/local/bin
              cd -
            fi
            ;;

          kubernetes)
            # Install kubectl if not present
            if ! command -v kubectl &> /dev/null; then
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
              chmod +x kubectl
              sudo mv kubectl /usr/local/bin/
            fi
            ;;
        esac

        echo "::endgroup::"

    # Create local cluster (kind or k3d) for Kubernetes provider if needed
    - name: Setup local Kubernetes cluster (if needed)
      id: local-cluster
      if: inputs.provider-type == 'kubernetes'
      shell: bash
      env:
        KUBECONFIG_SECRET: ${{ env.KUBECONFIG }}
      run: |
        echo "::group::Checking Kubernetes cluster availability"

        USE_LOCAL="${{ inputs.k8s-use-local-cluster }}"
        CLUSTER_TYPE="${{ inputs.k8s-local-cluster-type }}"
        CLUSTER_NAME="${{ inputs.k8s-local-cluster-name }}"

        # Auto-detect: use local cluster if no KUBECONFIG provided
        if [[ "$USE_LOCAL" == "auto" ]]; then
          if [[ -n "$KUBECONFIG_SECRET" ]] || [[ -f "$HOME/.kube/config" ]]; then
            echo "KUBECONFIG detected, using external cluster"
            USE_LOCAL="false"
          else
            echo "No KUBECONFIG detected, will create local $CLUSTER_TYPE cluster"
            USE_LOCAL="true"
          fi
        fi

        if [[ "$USE_LOCAL" == "true" ]]; then
          echo "Creating $CLUSTER_TYPE cluster with local registry for CI testing..."

          # Set up local registry (common for both kind and k3d)
          REG_NAME="local-registry-${CLUSTER_NAME}"
          REG_PORT="5001"

          if [ "$(docker inspect -f '{{.State.Running}}' "${REG_NAME}" 2>/dev/null || true)" != 'true' ]; then
            echo "Creating local registry: ${REG_NAME} on port ${REG_PORT}"
            docker run -d --restart=always -p "127.0.0.1:${REG_PORT}:5000" --network bridge --name "${REG_NAME}" registry:2
          else
            echo "Local registry ${REG_NAME} already running"
          fi

          if [[ "$CLUSTER_TYPE" == "kind" ]]; then
            # ===== KIND CLUSTER SETUP =====
            KIND_VERSION="${{ inputs.k8s-kind-version }}"
            NODE_IMAGE="${{ inputs.k8s-kind-node-image }}"

            # Always install the requested kind version (overwrite pre-installed version)
            # GitHub Actions runners may have a different version pre-installed that's
            # incompatible with our config format
            CURRENT_KIND_VERSION=$(kind version 2>/dev/null | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' || echo "none")
            if [[ "$CURRENT_KIND_VERSION" != "$KIND_VERSION" ]]; then
              echo "Installing kind ${KIND_VERSION} (current: ${CURRENT_KIND_VERSION})..."
              curl -Lo /tmp/kind "https://github.com/kubernetes-sigs/kind/releases/download/${KIND_VERSION}/kind-linux-amd64"
              chmod +x /tmp/kind
              sudo mv /tmp/kind /usr/local/bin/kind
            else
              echo "kind ${KIND_VERSION} already installed"
            fi
            kind version

            # Create kind config with registry support
            cat > /tmp/kind-config.yaml << 'KINDEOF'
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        containerdConfigPatches:
        - |-
          [plugins."io.containerd.grpc.v1.cri".registry]
            config_path = "/etc/containerd/certs.d"
        nodes:
          - role: control-plane
            extraPortMappings:
              - containerPort: 30000
                hostPort: 30000
                protocol: TCP
        KINDEOF
            sed -i 's/^        //' /tmp/kind-config.yaml

            kind delete cluster --name "$CLUSTER_NAME" 2>/dev/null || true

            echo "Creating kind cluster: $CLUSTER_NAME"
            kind create cluster \
              --name "$CLUSTER_NAME" \
              --image "$NODE_IMAGE" \
              --config /tmp/kind-config.yaml \
              --wait 120s

            # Connect registry to kind network
            if [ "$(docker inspect -f='{{json .NetworkSettings.Networks.kind}}' "${REG_NAME}")" = 'null' ]; then
              docker network connect "kind" "${REG_NAME}" || true
            fi

            # Configure containerd to use the local registry
            REGISTRY_DIR="/etc/containerd/certs.d/localhost:${REG_PORT}"
            for node in $(kind get nodes --name "$CLUSTER_NAME"); do
              echo "Configuring registry on node: ${node}"
              docker exec "${node}" mkdir -p "${REGISTRY_DIR}"
              docker exec "${node}" bash -c "echo '[host.\"http://${REG_NAME}:5000\"]' > ${REGISTRY_DIR}/hosts.toml && echo '  capabilities = [\"pull\", \"resolve\", \"push\"]' >> ${REGISTRY_DIR}/hosts.toml"
            done

            # Get kubeconfig
            mkdir -p "$HOME/.kube"
            kind get kubeconfig --name "$CLUSTER_NAME" > "$HOME/.kube/config"
            chmod 600 "$HOME/.kube/config"

          elif [[ "$CLUSTER_TYPE" == "k3d" ]]; then
            # ===== K3D CLUSTER SETUP =====
            K3D_VERSION="${{ inputs.k8s-k3d-version }}"
            K8S_VERSION="${{ inputs.k8s-k3d-k8s-version }}"

            # Always install the requested k3d version (overwrite pre-installed version)
            CURRENT_K3D_VERSION=$(k3d version 2>/dev/null | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "none")
            if [[ "$CURRENT_K3D_VERSION" != "$K3D_VERSION" ]]; then
              echo "Installing k3d ${K3D_VERSION} (current: ${CURRENT_K3D_VERSION})..."
              curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | TAG="${K3D_VERSION}" bash
            else
              echo "k3d ${K3D_VERSION} already installed"
            fi
            k3d version

            k3d cluster delete "$CLUSTER_NAME" 2>/dev/null || true

            echo "Creating k3d cluster: $CLUSTER_NAME"
            k3d cluster create "$CLUSTER_NAME" \
              --image "rancher/k3s:${K8S_VERSION}-k3s1" \
              --registry-use "k3d-${REG_NAME}:${REG_PORT}" \
              --port "30000:30000@server:0" \
              --wait

            # Connect registry to k3d network
            K3D_NETWORK="k3d-${CLUSTER_NAME}"
            if [ "$(docker inspect -f="{{json .NetworkSettings.Networks.\"${K3D_NETWORK}\"}}" "${REG_NAME}" 2>/dev/null)" = 'null' ]; then
              docker network connect "${K3D_NETWORK}" "${REG_NAME}" || true
            fi

            # Get kubeconfig
            mkdir -p "$HOME/.kube"
            k3d kubeconfig get "$CLUSTER_NAME" > "$HOME/.kube/config"
            chmod 600 "$HOME/.kube/config"

          else
            echo "::error::Unknown cluster type: $CLUSTER_TYPE (must be 'kind' or 'k3d')"
            exit 1
          fi

          # Common post-setup for both kind and k3d
          echo "Waiting for cluster to be ready..."
          kubectl wait --for=condition=Ready nodes --all --timeout=120s

          # Create namespace for DevPod
          kubectl create namespace "${{ inputs.k8s-namespace }}" --dry-run=client -o yaml | kubectl apply -f -

          # Create local registry hosting ConfigMap
          cat > /tmp/local-registry-cm.yaml << 'CMEOF'
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: local-registry-hosting
          namespace: kube-public
        data:
          localRegistryHosting.v1: |
            host: "REGISTRY_PLACEHOLDER"
            help: "https://kind.sigs.k8s.io/docs/user/local-registry/"
        CMEOF
          sed -i 's/^        //' /tmp/local-registry-cm.yaml
          sed -i "s/REGISTRY_PLACEHOLDER/localhost:${REG_PORT}/" /tmp/local-registry-cm.yaml
          kubectl apply -f /tmp/local-registry-cm.yaml

          echo "created=true" >> $GITHUB_OUTPUT
          echo "cluster-type=$CLUSTER_TYPE" >> $GITHUB_OUTPUT
          echo "cluster-name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "kubeconfig=$HOME/.kube/config" >> $GITHUB_OUTPUT
          echo "registry-url=localhost:${REG_PORT}" >> $GITHUB_OUTPUT
          echo "registry-name=${REG_NAME}" >> $GITHUB_OUTPUT

          echo "$CLUSTER_TYPE cluster '$CLUSTER_NAME' is ready with local registry at localhost:${REG_PORT}"
          kubectl cluster-info
          kubectl get nodes
        else
          echo "Using external Kubernetes cluster"

          # Write KUBECONFIG secret to file if provided as content
          if [[ -n "$KUBECONFIG_SECRET" ]] && [[ ! -f "$KUBECONFIG_SECRET" ]]; then
            mkdir -p "$HOME/.kube"
            echo "$KUBECONFIG_SECRET" > "$HOME/.kube/config"
            chmod 600 "$HOME/.kube/config"
          fi

          echo "created=false" >> $GITHUB_OUTPUT
          echo "cluster-type=" >> $GITHUB_OUTPUT
          echo "cluster-name=" >> $GITHUB_OUTPUT

          # Verify external cluster connectivity
          if kubectl cluster-info &>/dev/null; then
            echo "External cluster is accessible"
            kubectl cluster-info
          else
            echo "::warning::External cluster not accessible, tests may fail"
          fi
        fi

        echo "::endgroup::"

    - name: Configure provider
      id: configure
      shell: bash
      run: |
        echo "::group::Configuring DevPod provider"

        PROVIDER="${{ inputs.provider-type }}"
        PROVIDER_NAME="${{ inputs.provider-name }}"
        OPTIONS='${{ inputs.provider-options }}'

        # Handle devpod- prefix if present
        if [[ "$PROVIDER" == devpod-* ]]; then
          PROVIDER="${PROVIDER#devpod-}"
        fi

        # Use custom name if provided
        if [[ -n "$PROVIDER_NAME" ]]; then
          PROVIDER_ID="$PROVIDER_NAME"
        else
          PROVIDER_ID="$PROVIDER"
        fi

        # Add the provider
        echo "Adding provider: $PROVIDER as $PROVIDER_ID"
        devpod provider add "$PROVIDER" --name "$PROVIDER_ID" || true

        # Configure provider-specific options
        case "$PROVIDER" in
          aws)
            devpod provider set-options "$PROVIDER_ID" \
              --option AWS_REGION="${{ inputs.aws-region }}" \
              --option AWS_INSTANCE_TYPE="${{ inputs.aws-instance-type }}" \
              --option AWS_DISK_SIZE="${{ inputs.aws-disk-size }}"

            if [[ "${{ inputs.aws-use-spot }}" == "true" ]]; then
              devpod provider set-options "$PROVIDER_ID" --option AWS_USE_SPOT_INSTANCE=true
            fi
            ;;

          gcp)
            if [[ -n "${{ inputs.gcp-project }}" ]]; then
              devpod provider set-options "$PROVIDER_ID" \
                --option GCP_PROJECT="${{ inputs.gcp-project }}" \
                --option GCP_ZONE="${{ inputs.gcp-zone }}" \
                --option GCP_MACHINE_TYPE="${{ inputs.gcp-machine-type }}"
            fi
            ;;

          azure)
            if [[ -n "${{ inputs.azure-subscription }}" ]]; then
              devpod provider set-options "$PROVIDER_ID" \
                --option AZURE_SUBSCRIPTION="${{ inputs.azure-subscription }}" \
                --option AZURE_RESOURCE_GROUP="${{ inputs.azure-resource-group }}" \
                --option AZURE_LOCATION="${{ inputs.azure-location }}" \
                --option AZURE_VM_SIZE="${{ inputs.azure-vm-size }}"
            fi
            ;;

          digitalocean)
            devpod provider set-options "$PROVIDER_ID" \
              --option DIGITALOCEAN_REGION="${{ inputs.do-region }}" \
              --option DIGITALOCEAN_SIZE="${{ inputs.do-size }}"
            ;;

          kubernetes)
            # Expand ~ to $HOME for kubeconfig path (DevPod doesn't expand tilde)
            K8S_CONFIG="${{ inputs.k8s-config-path }}"
            K8S_CONFIG="${K8S_CONFIG/#\~/$HOME}"
            devpod provider set-options "$PROVIDER_ID" \
              --option KUBERNETES_CONFIG="$K8S_CONFIG" \
              --option KUBERNETES_NAMESPACE="${{ inputs.k8s-namespace }}"

            if [[ -n "${{ inputs.k8s-context }}" ]]; then
              devpod provider set-options "$PROVIDER_ID" \
                --option KUBERNETES_CONTEXT="${{ inputs.k8s-context }}"
            fi
            ;;

          ssh)
            if [[ -n "${{ inputs.ssh-host }}" ]]; then
              devpod provider set-options "$PROVIDER_ID" \
                --option SSH_HOST="${{ inputs.ssh-host }}" \
                --option SSH_USER="${{ inputs.ssh-user }}" \
                --option SSH_KEY_PATH="${{ inputs.ssh-key-path }}"
            fi
            ;;
        esac

        # Apply any additional custom options from JSON
        if [[ "$OPTIONS" != "{}" ]]; then
          echo "$OPTIONS" | jq -r 'to_entries[] | "--option \(.key)=\(.value)"' | \
          while read -r opt; do
            eval "devpod provider set-options $PROVIDER_ID $opt"
          done
        fi

        # Set inactivity timeout for all providers
        devpod provider set-options "$PROVIDER_ID" --option INACTIVITY_TIMEOUT=10m

        # Get provider configuration
        CONFIG=$(devpod provider options "$PROVIDER_ID" --output json || echo '{}')

        echo "provider-id=$PROVIDER_ID" >> $GITHUB_OUTPUT

        {
          echo "config<<EOF"
          echo "$CONFIG"
          echo "EOF"
        } >> $GITHUB_OUTPUT

        echo "::endgroup::"

    - name: Verify provider setup
      id: verify
      shell: bash
      run: |
        echo "::group::Verifying provider setup"

        PROVIDER_ID="${{ steps.configure.outputs.provider-id }}"

        # Check provider is available
        if devpod provider list | grep -q "$PROVIDER_ID"; then
          echo "✅ Provider $PROVIDER_ID is configured"
          STATUS="ready"
        else
          echo "❌ Provider $PROVIDER_ID not found"
          STATUS="error"
          exit 1
        fi

        # Display provider info
        devpod provider list

        echo "status=$STATUS" >> $GITHUB_OUTPUT

        echo "::endgroup::"
