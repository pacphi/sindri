name: Cleanup Fly.io Resources
description: Cleans up Fly.io apps, machines, and volumes

inputs:
  app-name:
    description: Fly.io app name to cleanup
    required: false
    default: ""
  fly-api-token:
    description: Fly.io API token
    required: true
  cleanup-pattern:
    description: Pattern to match apps for cleanup
    required: false
    default: ""
  force:
    description: Force cleanup without confirmation
    required: false
    default: "true"
  cleanup-volumes:
    description: Also cleanup volumes
    required: false
    default: "true"
  cleanup-secrets:
    description: Clear all secrets before deletion
    required: false
    default: "true"
  max-age-hours:
    description: Only cleanup apps older than this many hours
    required: false
    default: "0"

outputs:
  cleaned-apps:
    description: List of cleaned app names
    value: ${{ steps.cleanup.outputs.cleaned }}
  cleanup-status:
    description: Cleanup operation status
    value: ${{ steps.cleanup.outputs.status }}

runs:
  using: composite
  steps:
    - name: List current apps
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Current Fly.io apps"

        flyctl apps list || echo "No apps found"

        echo "::endgroup::"

    - name: Cleanup specific app
      if: inputs.app-name != ''
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Cleaning up app: ${{ inputs.app-name }}"

        APP_NAME="${{ inputs.app-name }}"
        FORCE="${{ inputs.force }}"

        # Check if app exists
        if flyctl apps list 2>/dev/null | grep -q "$APP_NAME"; then
          # Clear secrets if requested (skip if no machines deployed)
          if [[ "${{ inputs.cleanup-secrets }}" == "true" ]]; then
            echo "Clearing secrets..."
            SECRETS=$(flyctl secrets list -a "$APP_NAME" --json 2>/dev/null || echo "[]")
            if [[ "$SECRETS" != "[]" && "$SECRETS" != "null" ]]; then
              echo "$SECRETS" | jq -r '.[].Name // empty' 2>/dev/null | \
                while read -r secret_name; do
                  [[ -n "$secret_name" ]] && flyctl secrets unset "$secret_name" -a "$APP_NAME" --stage 2>/dev/null || true
                done
              # Only deploy secrets if there are machines
              MACHINES=$(flyctl machine list -a "$APP_NAME" --json 2>/dev/null || echo "[]")
              if [[ "$MACHINES" != "[]" ]]; then
                flyctl secrets deploy -a "$APP_NAME" 2>/dev/null || true
              fi
            fi
          fi

          # Stop and destroy all machines (force destroy handles stuck machines)
          echo "Destroying machines..."
          MACHINES=$(flyctl machine list -a "$APP_NAME" --json 2>/dev/null || echo "[]")
          echo "$MACHINES" | jq -r '.[].id // empty' 2>/dev/null | \
            while read -r machine_id; do
              if [[ -n "$machine_id" ]]; then
                echo "  Destroying machine: $machine_id"
                # Use force destroy - this works even if machine is in transitional state
                flyctl machine destroy "$machine_id" -a "$APP_NAME" --force 2>/dev/null || true
              fi
            done

          # Brief wait for machine cleanup
          sleep 2

          # Delete app with retry logic for pending/stuck apps
          echo "Deleting app..."
          DELETE_SUCCESS=false
          for attempt in 1 2 3; do
            echo "  Attempt $attempt to delete app..."
            if [[ "$FORCE" == "true" ]]; then
              if flyctl apps destroy "$APP_NAME" --yes 2>&1; then
                DELETE_SUCCESS=true
                break
              fi
            else
              if flyctl apps destroy "$APP_NAME" 2>&1; then
                DELETE_SUCCESS=true
                break
              fi
            fi
            # Wait before retry (Fly.io may need time to process pending state)
            sleep 5
          done

          # Verify the app was actually deleted
          sleep 2
          if flyctl apps list 2>/dev/null | grep -q "^${APP_NAME}[[:space:]]"; then
            echo "::warning::App $APP_NAME still exists after cleanup attempts"
            echo "⚠️ App $APP_NAME may require manual deletion"
            echo "  Run: flyctl apps destroy $APP_NAME --yes"
          else
            echo "✅ App $APP_NAME cleaned up successfully"
          fi
        else
          echo "⚠️ App $APP_NAME not found"
        fi

        echo "::endgroup::"

    - name: Cleanup apps by pattern
      if: inputs.cleanup-pattern != ''
      id: cleanup
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Cleaning up apps matching pattern: ${{ inputs.cleanup-pattern }}"

        PATTERN="${{ inputs.cleanup-pattern }}"
        MAX_AGE_HOURS="${{ inputs.max-age-hours }}"
        FORCE="${{ inputs.force }}"
        CLEANED="[]"

        # Get apps matching pattern
        APPS=$(flyctl apps list --json | \
          jq -r ".[] | select(.Name | contains(\"$PATTERN\")) | .Name" || echo "")

        if [[ -z "$APPS" ]]; then
          echo "No apps found matching pattern: $PATTERN"
          STATUS="no-apps"
        else
          CURRENT_TIME=$(date +%s)

          for app in $APPS; do
            # Check app age if max-age-hours is set
            if [[ "$MAX_AGE_HOURS" -gt 0 ]]; then
              CREATED_AT=$(flyctl apps list --json | \
                jq -r ".[] | select(.Name == \"$app\") | .CreatedAt" || echo "")

              if [[ -n "$CREATED_AT" ]]; then
                APP_TIME=$(date -d "$CREATED_AT" +%s 2>/dev/null || date +%s)
                AGE_HOURS=$(( (CURRENT_TIME - APP_TIME) / 3600 ))

                if [[ $AGE_HOURS -lt $MAX_AGE_HOURS ]]; then
                  echo "Skipping $app (age: ${AGE_HOURS}h < ${MAX_AGE_HOURS}h)"
                  continue
                fi
              fi
            fi

            echo "Cleaning up app: $app"

            # Clear secrets
            if [[ "${{ inputs.cleanup-secrets }}" == "true" ]]; then
              flyctl secrets list -a "$app" --json | \
                jq -r '.[].Name' | \
                xargs -I {} flyctl secrets unset {} -a "$app" --stage || true
              flyctl secrets deploy -a "$app" || true
            fi

            # Stop machines
            flyctl machine list -a "$app" --json | jq -r '.[].id' | \
              while read -r machine_id; do
                flyctl machine stop "$machine_id" -a "$app" || true
              done

            # Delete app
            if [[ "$FORCE" == "true" ]]; then
              flyctl apps destroy "$app" --yes || true
            else
              flyctl apps destroy "$app" || true
            fi

            # Add to cleaned list
            CLEANED=$(echo "$CLEANED" | jq --arg app "$app" '. + [$app]')
          done

          STATUS="success"
          echo "✅ Cleaned up $(echo "$CLEANED" | jq '. | length') apps"
        fi

        echo "cleaned=$CLEANED" >> $GITHUB_OUTPUT
        echo "status=$STATUS" >> $GITHUB_OUTPUT

        echo "::endgroup::"

    - name: Cleanup orphaned volumes
      if: inputs.cleanup-volumes == 'true' && inputs.app-name != ''
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Cleaning up orphaned volumes for app: ${{ inputs.app-name }}"

        APP_NAME="${{ inputs.app-name }}"

        # List volumes for the specific app (flyctl volumes list requires -a flag)
        VOLUMES=$(flyctl volumes list -a "$APP_NAME" --json 2>/dev/null || echo "[]")

        # Check for orphaned volumes (volumes not attached to any machine)
        echo "$VOLUMES" | jq -r '.[] | select(.attached_machine_id == null) | .id' | \
          while read -r volume_id; do
            if [[ -n "$volume_id" && "$volume_id" != "null" ]]; then
              echo "Deleting orphaned volume: $volume_id"
              flyctl volumes destroy "$volume_id" --yes || true
            fi
          done

        echo "::endgroup::"

    - name: Final status
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Final status"

        echo "Remaining apps:"
        flyctl apps list || echo "No apps"

        echo "::endgroup::"
