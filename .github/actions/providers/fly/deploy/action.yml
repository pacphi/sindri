name: Deploy to Fly.io
description: Deploys Sindri to Fly.io infrastructure using pre-built images

inputs:
  app-name:
    description: Fly.io app name
    required: true
  fly-api-token:
    description: Fly.io API token
    required: true
  region:
    description: Deployment region
    required: false
    default: sjc
  vm-size:
    description: VM size (shared-cpu-1x, dedicated-cpu-1x, etc.)
    required: false
    default: shared-cpu-1x
  vm-memory:
    description: VM memory in MB
    required: false
    default: "1024"
  volume-size:
    description: Volume size in GB
    required: false
    default: "10"
  extension-profile:
    description: Extension profile to install
    required: false
    default: ""
  secrets:
    description: JSON object with secrets to set
    required: false
    default: "{}"
  deployment-strategy:
    description: Deployment strategy (immediate, rolling, canary)
    required: false
    default: immediate
  wait-for-deployment:
    description: Wait for deployment to complete
    required: false
    default: "true"
  timeout-seconds:
    description: Deployment timeout in seconds
    required: false
    default: "300"
  image-tag:
    description: Tag for the Docker image (defaults to git SHA)
    required: false
    default: ""
  image:
    description: Pre-built Docker image to deploy (e.g., sindri:ci-abc123)
    required: false
    default: ""
  ci-mode:
    description: Enable CI mode (skips SSH daemon, uses flyctl ssh console)
    required: false
    default: "true"

outputs:
  machine-id:
    description: Fly.io machine ID
    value: ${{ steps.deploy.outputs.machine-id }}
  deployment-id:
    description: Deployment ID
    value: ${{ steps.deploy.outputs.deployment-id }}
  app-url:
    description: Application URL
    value: ${{ steps.deploy.outputs.app-url }}
  status:
    description: Deployment status
    value: ${{ steps.verify.outputs.status }}

runs:
  using: composite
  steps:
    - name: Configure deployment
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Configuring deployment"

        APP_NAME="${{ inputs.app-name }}"

        # Note: VM size and memory are passed directly to flyctl deploy command
        # yq doesn't fully support TOML output format, so we avoid editing fly.toml

        # Verify the app exists before proceeding
        if ! flyctl apps list | grep -q "$APP_NAME"; then
          echo "::error::App $APP_NAME not found. Ensure setup action ran successfully."
          exit 1
        fi

        # Create or update volume (must match mount source in fly.toml: "home_data")
        VOLUME_EXISTS=$(flyctl volumes list -a "$APP_NAME" --json | jq -r '.[0].id' || echo "")
        if [[ -z "$VOLUME_EXISTS" || "$VOLUME_EXISTS" == "null" ]]; then
          echo "Creating volume home_data..."
          if ! flyctl volumes create home_data \
            --app "$APP_NAME" \
            --region "${{ inputs.region }}" \
            --size "${{ inputs.volume-size }}" --yes; then
            echo "::warning::Volume creation failed, deployment may still succeed with auto-created volume"
          fi
        else
          echo "Volume already exists: $VOLUME_EXISTS"
        fi

        echo "::endgroup::"

    - name: Set secrets
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Setting secrets"

        APP_NAME="${{ inputs.app-name }}"
        SECRETS='${{ inputs.secrets }}'

        # Set CI_MODE if enabled
        if [[ "${{ inputs.ci-mode }}" == "true" ]]; then
          echo "Setting CI_MODE=true (SSH daemon disabled, use flyctl ssh console)"
          flyctl secrets set "CI_MODE=true" -a "$APP_NAME" --stage || true
        fi

        # Parse and set each secret from inputs
        if [[ "$SECRETS" != "{}" ]]; then
          echo "$SECRETS" | jq -r 'to_entries[] | "\(.key)=\(.value)"' | \
          while IFS='=' read -r key value; do
            echo "Setting secret: $key"
            flyctl secrets set "$key=$value" -a "$APP_NAME" --stage || true
          done
        fi

        # Deploy staged secrets
        flyctl secrets deploy -a "$APP_NAME" || true

        echo "::endgroup::"

    - name: Push image to Fly.io registry
      id: push-image
      if: inputs.image != ''
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Pushing image to Fly.io registry"

        APP_NAME="${{ inputs.app-name }}"
        SOURCE_IMAGE="${{ inputs.image }}"
        IMAGE_TAG="${{ inputs.image-tag }}"

        # Use provided tag or extract from source image
        if [[ -z "$IMAGE_TAG" ]]; then
          IMAGE_TAG="$(echo "$SOURCE_IMAGE" | cut -d: -f2)"
          [[ -z "$IMAGE_TAG" || "$IMAGE_TAG" == "$SOURCE_IMAGE" ]] && IMAGE_TAG="latest"
        fi

        REGISTRY_IMAGE="registry.fly.io/${APP_NAME}:${IMAGE_TAG}"

        echo "Source image: $SOURCE_IMAGE"
        echo "Target image: $REGISTRY_IMAGE"

        # Authenticate Docker with Fly.io registry
        flyctl auth docker

        # Tag the pre-built image for Fly.io registry
        docker tag "$SOURCE_IMAGE" "$REGISTRY_IMAGE"

        # Push to Fly.io registry
        echo "Pushing to Fly.io registry..."
        docker push "$REGISTRY_IMAGE"

        echo "registry-image=$REGISTRY_IMAGE" >> $GITHUB_OUTPUT
        echo "✅ Image pushed: $REGISTRY_IMAGE"

        echo "::endgroup::"

    - name: Deploy application
      id: deploy
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Deploying to Fly.io"

        APP_NAME="${{ inputs.app-name }}"
        STRATEGY="${{ inputs.deployment-strategy }}"
        TIMEOUT="${{ inputs.timeout-seconds }}"
        REGISTRY_IMAGE="${{ steps.push-image.outputs.registry-image }}"

        # Show fly.toml for debugging
        echo "=== fly.toml contents ==="
        cat fly.toml
        echo "========================="

        # Set environment variables
        if [[ -n "${{ inputs.extension-profile }}" ]]; then
          export INSTALL_PROFILE="${{ inputs.extension-profile }}"
        fi

        # Deploy with pre-built image or build locally
        echo "Deploying with strategy: $STRATEGY"

        set +e  # Don't exit on error, capture it
        if [[ -n "$REGISTRY_IMAGE" ]]; then
          echo "Deploying pre-built image: $REGISTRY_IMAGE"
          DEPLOY_OUTPUT=$(flyctl deploy \
            --app "$APP_NAME" \
            --image "$REGISTRY_IMAGE" \
            --ha=false \
            --vm-memory "${{ inputs.vm-memory }}" \
            --strategy "$STRATEGY" \
            --wait-timeout "${TIMEOUT}s" \
            --yes \
            --verbose 2>&1 | tee /tmp/fly-deploy.log)
        else
          echo "No pre-built image provided, building with --local-only"
          DEPLOY_OUTPUT=$(flyctl deploy \
            --app "$APP_NAME" \
            --local-only \
            --ha=false \
            --vm-memory "${{ inputs.vm-memory }}" \
            --strategy "$STRATEGY" \
            --wait-timeout "${TIMEOUT}s" \
            --yes \
            --verbose 2>&1 | tee /tmp/fly-deploy.log)
        fi
        DEPLOY_EXIT_CODE=$?
        set -e

        if [[ $DEPLOY_EXIT_CODE -ne 0 ]]; then
          echo "::warning::Deploy command exited with code $DEPLOY_EXIT_CODE"
          echo "Deploy output:"
          cat /tmp/fly-deploy.log
        fi

        # Extract deployment information
        DEPLOYMENT_ID=$(echo "$DEPLOY_OUTPUT" | grep -oP 'Deployment ID: \K[^ ]+' || echo "unknown")
        MACHINE_ID=$(flyctl machine list -a "$APP_NAME" --json 2>/dev/null | jq -r '.[0].id // empty' || echo "")
        APP_URL="https://${APP_NAME}.fly.dev"

        echo "machine-id=$MACHINE_ID" >> $GITHUB_OUTPUT
        echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
        echo "app-url=$APP_URL" >> $GITHUB_OUTPUT

        echo "::notice title=Deployment Info::Machine ID: $MACHINE_ID, URL: $APP_URL"

        echo "::endgroup::"

    - name: Wait for deployment
      if: inputs.wait-for-deployment == 'true'
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Waiting for deployment to complete"

        APP_NAME="${{ inputs.app-name }}"
        TIMEOUT="${{ inputs.timeout-seconds }}"
        START_TIME=$(date +%s)

        # Initial wait for machine to be created
        sleep 5

        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [[ $ELAPSED -gt $TIMEOUT ]]; then
            echo "❌ Timeout waiting for deployment after ${ELAPSED}s"
            echo ""
            echo "=== Diagnostic Information ==="
            echo "App status:"
            flyctl status -a "$APP_NAME" 2>&1 || true
            echo ""
            echo "Machine list:"
            flyctl machine list -a "$APP_NAME" 2>&1 || true
            echo ""
            echo "Recent logs:"
            flyctl logs -a "$APP_NAME" --no-tail 2>&1 | tail -50 || true
            echo "=============================="
            exit 1
          fi

          # Check machine status
          MACHINE_JSON=$(flyctl machine list -a "$APP_NAME" --json 2>/dev/null || echo "[]")
          STATUS=$(echo "$MACHINE_JSON" | jq -r '.[0].state // "no-machine"')
          MACHINE_ID=$(echo "$MACHINE_JSON" | jq -r '.[0].id // "none"')

          echo "Machine $MACHINE_ID status: $STATUS (elapsed: ${ELAPSED}s)"

          if [[ "$STATUS" == "started" ]]; then
            echo "✅ Deployment successful - machine is running"
            break
          elif [[ "$STATUS" == "failed" ]] || [[ "$STATUS" == "destroyed" ]] || [[ "$STATUS" == "crashed" ]]; then
            echo "❌ Deployment failed with status: $STATUS"
            echo "Fetching logs for diagnostics..."
            flyctl logs -a "$APP_NAME" --no-tail 2>&1 | tail -100 || true
            exit 1
          elif [[ "$STATUS" == "no-machine" ]]; then
            echo "⏳ Waiting for machine to be created..."
          fi

          sleep 10
        done

        echo "::endgroup::"

    - name: Verify deployment
      id: verify
      shell: bash
      env:
        FLY_API_TOKEN: ${{ inputs.fly-api-token }}
      run: |
        echo "::group::Verifying deployment"

        APP_NAME="${{ inputs.app-name }}"

        # Test SSH connectivity
        echo "Testing SSH connectivity..."
        if flyctl ssh console -a "$APP_NAME" --command "echo 'SSH connection successful'"; then
          echo "✅ SSH connectivity verified"
          SSH_STATUS="success"
        else
          echo "❌ SSH connectivity failed"
          SSH_STATUS="failure"
        fi

        # Test volume mount
        # Check if /alt/home/developer exists and is writable (avoids quoting issues with pipe/grep)
        echo "Testing volume mount..."
        if flyctl ssh console -a "$APP_NAME" --command "test -d /alt/home/developer -a -w /alt/home/developer && echo 'Volume accessible'"; then
          echo "✅ Volume mounted successfully"
          VOLUME_STATUS="success"
        else
          echo "❌ Volume mount failed or not writable"
          VOLUME_STATUS="failure"
        fi

        # Overall status
        if [[ "$SSH_STATUS" == "success" ]] && [[ "$VOLUME_STATUS" == "success" ]]; then
          STATUS="success"
        else
          STATUS="partial"
        fi

        echo "status=$STATUS" >> $GITHUB_OUTPUT

        echo "::endgroup::"
