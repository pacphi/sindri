# Integration tests with enhanced resilience for registry failures
# This workflow includes comprehensive retry logic for all registry-dependent operations

name: Integration Tests (Resilient)

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}

permissions:
  contents: read

jobs:
  integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Setup retry utilities
        id: retry-setup
        shell: bash
        run: |
          # Create comprehensive retry function
          cat > /tmp/retry_utils.sh << 'RETRY_EOF'
          #!/bin/bash

          # Generic retry with exponential backoff
          retry_with_backoff() {
            local max_attempts=${1:-3}
            local initial_delay=${2:-5}
            local max_delay=${3:-60}
            local attempt=1
            local exit_code=0

            shift 3

            while [ $attempt -le $max_attempts ]; do
              echo "‚ñ∂Ô∏è  Attempt $attempt of $max_attempts: $@"

              if "$@"; then
                echo "‚úÖ Command succeeded"
                return 0
              else
                exit_code=$?

                if [ $attempt -lt $max_attempts ]; then
                  local wait_time=$((initial_delay * attempt))
                  [ $wait_time -gt $max_delay ] && wait_time=$max_delay

                  echo "‚ö†Ô∏è  Command failed (exit: $exit_code), retrying in ${wait_time}s..."
                  sleep $wait_time
                  attempt=$((attempt + 1))
                else
                  echo "‚ùå Command failed after $max_attempts attempts (exit: $exit_code)"
                  return $exit_code
                fi
              fi
            done
          }

          # Flyctl deployment with retry
          flyctl_deploy_retry() {
            local app_name=$1
            local max_attempts=4
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              echo "‚ñ∂Ô∏è  Deployment attempt $attempt of $max_attempts for $app_name..."

              # Add timeout to prevent indefinite hangs (increased for image build)
              if timeout 300s flyctl deploy \
                --app "$app_name" \
                --strategy immediate \
                --wait-timeout 300s \
                --yes; then
                echo "‚úÖ Deployment successful"
                return 0
              else
                local exit_code=$?

                if [ $attempt -lt $max_attempts ]; then
                  local wait_time=$((15 * attempt))
                  echo "‚ö†Ô∏è  Deployment failed (exit: $exit_code), retrying in ${wait_time}s..."

                  # Check if it's a registry issue
                  if flyctl logs -a "$app_name" 2>&1 | grep -i "registry\|pull\|image"; then
                    echo "üîç Detected potential registry issue in logs"
                  fi

                  sleep $wait_time
                  attempt=$((attempt + 1))
                else
                  echo "‚ùå Deployment failed after $max_attempts attempts"
                  echo "üìã Final logs:"
                  flyctl logs -a "$app_name" || true
                  return $exit_code
                fi
              fi
            done
          }

          # SSH command with retry
          ssh_command_retry() {
            local app_name=$1
            shift
            local command="$@"
            local max_attempts=5
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              echo "‚ñ∂Ô∏è  SSH attempt $attempt of $max_attempts..."

              if timeout 45s flyctl ssh console -a "$app_name" --user developer -C "$command"; then
                echo "‚úÖ SSH command succeeded"
                return 0
              else
                local exit_code=$?

                if [ $attempt -lt $max_attempts ]; then
                  local wait_time=$((3 * attempt))
                  echo "‚ö†Ô∏è  SSH failed (exit: $exit_code), retrying in ${wait_time}s..."
                  sleep $wait_time
                  attempt=$((attempt + 1))
                else
                  echo "‚ùå SSH command failed after $max_attempts attempts"
                  return $exit_code
                fi
              fi
            done
          }

          # Machine readiness check with retry
          wait_for_machine_ready() {
            local app_name=$1
            local max_attempts=90  # 180 seconds total (increased for CI stability)
            local attempt=1

            echo "‚è≥ Waiting for machine to be ready..."

            while [ $attempt -le $max_attempts ]; do
              # Capture status for logging
              status_output=$(flyctl status -a "$app_name" 2>&1)

              # Check for "started" (immediate deployment bypasses health checks)
              if echo "$status_output" | grep -q "started"; then
                echo "‚úÖ Machine is started"
                echo "$status_output"

                # Give SSH daemon time to fully initialize (critical for CI)
                sleep 15

                # Additional check: can we execute a simple command?
                if timeout 15s flyctl ssh console -a "$app_name" --user developer -C "echo ready" &>/dev/null; then
                  echo "‚úÖ Machine is responsive"
                  return 0
                else
                  echo "‚ö†Ô∏è  Machine started but not responsive yet (attempt $attempt/$max_attempts)..."
                fi
              else
                # Log progress every 10 attempts to avoid spam
                [ $((attempt % 10)) -eq 0 ] && echo "‚è≥ Still waiting... (attempt $attempt/$max_attempts)"
              fi

              sleep 2
              attempt=$((attempt + 1))
            done

            echo "‚ùå Machine failed to become ready after $max_attempts attempts"
            echo "Final status:"
            flyctl status -a "$app_name" 2>&1 || true
            return 1
          }

          export -f retry_with_backoff
          export -f flyctl_deploy_retry
          export -f ssh_command_retry
          export -f wait_for_machine_ready
          RETRY_EOF

          chmod +x /tmp/retry_utils.sh
          source /tmp/retry_utils.sh

          echo "‚úÖ Retry utilities configured"

      - name: Generate unique app name
        id: app-name
        run: |
          TIMESTAMP=$(date +%s)
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          APP_NAME="sindri-test-${SHORT_SHA}-${TIMESTAMP}"
          echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "Generated app name: ${APP_NAME}"

      - name: Prepare fly.toml for testing
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "5"
          VM_MEMORY: "1024"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
          CI_MODE: "true"
        run: |
          # Use the configuration script in CI mode to prevent port conflicts
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Create Fly.io app and volume
        run: |
          source /tmp/retry_utils.sh

          echo "üî® Creating Fly.io app and resources..."

          # Create app with retry
          if retry_with_backoff 3 5 30 \
            flyctl apps create "${{ steps.app-name.outputs.app_name }}" --org personal; then
            echo "‚úÖ App created successfully"
          else
            echo "‚ö†Ô∏è  App creation failed, may already exist"
          fi

          # Create volume with retry
          if retry_with_backoff 3 5 30 \
            flyctl volumes create test_data \
              --app "${{ steps.app-name.outputs.app_name }}" \
              --region sjc \
              --size 5 \
              --no-encryption \
              --yes; then
            echo "‚úÖ Volume created successfully"
          else
            echo "‚ùå Volume creation failed"
            exit 1
          fi

          # Set secrets (no retry needed for secrets)
          echo "Setting CI_MODE secret..."
          if flyctl secrets set CI_MODE="true" \
            --app "${{ steps.app-name.outputs.app_name }}"; then
            echo "‚úÖ Secrets configured"
          else
            echo "‚ùå Secret configuration failed"
            exit 1
          fi

      - name: Deploy VM with retry logic
        timeout-minutes: 10
        run: |
          source /tmp/retry_utils.sh

          echo "üöÄ Deploying test VM: ${{ steps.app-name.outputs.app_name }}"

          # Use flyctl_deploy_retry for resilient deployment
          if flyctl_deploy_retry "${{ steps.app-name.outputs.app_name }}"; then
            echo "‚úÖ Deployment completed"
          else
            echo "‚ùå Deployment failed after all retries"
            exit 1
          fi

      - name: Wait for machine readiness
        timeout-minutes: 5
        run: |
          source /tmp/retry_utils.sh

          if wait_for_machine_ready "${{ steps.app-name.outputs.app_name }}"; then
            echo "‚úÖ Machine ready for testing"
          else
            echo "‚ùå Machine failed readiness check"
            flyctl status -a "${{ steps.app-name.outputs.app_name }}" || true
            exit 1
          fi

      - name: Test SSH connectivity with retry
        timeout-minutes: 5
        run: |
          source /tmp/retry_utils.sh

          echo "üîç Testing SSH connectivity..."

          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" "echo 'SSH connection successful'"; then
            echo "‚úÖ SSH connectivity confirmed"
          else
            echo "‚ùå SSH connectivity test failed"
            exit 1
          fi

      - name: Test volume persistence with retry
        timeout-minutes: 5
        run: |
          source /tmp/retry_utils.sh

          echo "üîç Testing volume persistence..."

          # Write test data (use timestamp instead of $$ for consistency)
          TEST_FILE="/workspace/test-persistence-$(date +%s).txt"
          TEST_DATA="persistence-test-$(date +%s)"

          echo "Test file: $TEST_FILE"
          echo "Test data: $TEST_DATA"

          # Create test file with explicit sync operations (matching integration.yml)
          echo "Creating test file with content: $TEST_DATA"
          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" "/bin/bash -c '
            echo \"Creating and syncing test file...\"
            echo \"$TEST_DATA\" > $TEST_FILE
            sync
            sleep 2
            echo \"Verifying file was written correctly...\"
            if [ -f \"$TEST_FILE\" ]; then
              file_size=\$(wc -c < \"$TEST_FILE\")
              echo \"File created with size: \$file_size bytes\"
              cat \"$TEST_FILE\"
            else
              echo \"ERROR: File was not created\"
              exit 1
            fi
          '"; then
            echo "‚úÖ Volume write successful"
          else
            echo "‚ùå Volume write failed"
            exit 1
          fi

          # Force filesystem sync before restart (matching integration.yml)
          echo "Forcing filesystem sync before restart..."
          ssh_command_retry "${{ steps.app-name.outputs.app_name }}" "/bin/bash -c '
            echo \"Syncing filesystem before restart...\"
            sync
            echo \"Sync completed\"
            sleep 3
            echo \"Final file verification before restart:\"
            ls -la \"$TEST_FILE\" 2>/dev/null || echo \"File not found\"
            wc -c \"$TEST_FILE\" 2>/dev/null || echo \"Cannot get file size\"
            cat \"$TEST_FILE\" 2>/dev/null || echo \"Cannot read file\"
          '"

          # Wait additional time for any remaining buffer flushes (matching integration.yml)
          echo "Waiting for buffer flush before restart..."
          sleep 10

          # Restart machine
          echo "üîÑ Restarting machine..."
          MACHINE_ID=$(flyctl status -a "${{ steps.app-name.outputs.app_name }}" --json | jq -r '.Machines[0].id')

          if retry_with_backoff 3 5 30 flyctl machine restart "$MACHINE_ID" -a "${{ steps.app-name.outputs.app_name }}"; then
            echo "‚úÖ Machine restarted"
          else
            echo "‚ùå Machine restart failed"
            exit 1
          fi

          # Wait for machine to restart and become ready (increased from 10s)
          echo "Waiting for machine to restart and become ready..."
          sleep 45
          wait_for_machine_ready "${{ steps.app-name.outputs.app_name }}"

          # Verify persistence with comprehensive check
          echo "üîç Verifying data persistence..."
          echo "Looking for file: $TEST_FILE"
          echo "Expected content: $TEST_DATA"

          # Use comprehensive verification (same as integration.yml)
          verification_result=$(flyctl ssh console -a "${{ steps.app-name.outputs.app_name }}" --user developer -C "/bin/bash -c '
            echo \"=== Post-Restart File Verification ===\"
            if [ -f \"$TEST_FILE\" ]; then
              echo \"‚úÖ File exists\"
              echo \"File metadata:\"
              ls -la \"$TEST_FILE\"
              echo \"File size: \$(wc -c < \"$TEST_FILE\") bytes\"
              echo \"File content:\"
              content=\$(cat \"$TEST_FILE\" 2>/dev/null)
              if [ -n \"\$content\" ]; then
                echo \"\$content\"
                echo \"VERIFICATION_STATUS=SUCCESS\"
              else
                echo \"[EMPTY FILE]\"
                echo \"VERIFICATION_STATUS=EMPTY\"
              fi
            else
              echo \"‚ùå File missing\"
              echo \"VERIFICATION_STATUS=MISSING\"
            fi
            echo \"=== End Verification ===\"
          '")

          echo "$verification_result"

          if echo "$verification_result" | grep -q "VERIFICATION_STATUS=SUCCESS"; then
            echo "‚úÖ Test file exists with content after restart"

            # Extract and verify content
            actual_content=$(echo "$verification_result" | grep -A 1 "File content:" | tail -1)

            if [ "$actual_content" = "$TEST_DATA" ]; then
              echo "‚úÖ Volume persistence confirmed - content matches perfectly"
            else
              echo "‚ùå File content mismatch:"
              echo "  Expected: '$TEST_DATA'"
              echo "  Actual:   '$actual_content'"
              echo "  Expected length: ${#TEST_DATA}"
              echo "  Actual length:   ${#actual_content}"
              exit 1
            fi
          elif echo "$verification_result" | grep -q "VERIFICATION_STATUS=EMPTY"; then
            echo "‚ùå File exists but is empty - filesystem sync failure"
            echo "Debugging information:"
            echo "$verification_result"
            exit 1
          else
            echo "‚ùå Test file not found after restart"
            echo "Debugging information:"
            echo "$verification_result"
            exit 1
          fi

      - name: Setup extension manifest with protected extensions
        timeout-minutes: 5
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Setting up manifest with protected core extensions..."
          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            cd /workspace/scripts/lib
            manifest_file=\"extensions.d/active-extensions.conf\"

            # Create manifest from CI template (has protected extensions: workspace-structure, mise-config, ssh-environment)
            if [ ! -f \"\$manifest_file\" ]; then
              cp extensions.d/active-extensions.ci.conf \"\$manifest_file\" 2>/dev/null || touch \"\$manifest_file\"
            fi

            echo \"\"
            echo \"=== Protected Extensions in Manifest (from CI config) ===\"
            grep -v \"^[[:space:]]*#\" \"\$manifest_file\" | grep -v \"^[[:space:]]*$\" || echo \"(empty)\"
          '"

      - name: Install protected extensions
        timeout-minutes: 8
        run: |
          source /tmp/retry_utils.sh
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Installing protected extensions (workspace-structure, mise-config, ssh-environment)..."
          if retry_with_backoff 3 10 60 \
            flyctl ssh console -a "$app_name" --user developer \
              -C "/bin/bash -lc 'cd /workspace/scripts/lib && bash extension-manager.sh install-all'"; then
            echo "‚úÖ Protected extensions installed"
          else
            echo "‚ùå Protected extensions installation failed"
            exit 1
          fi

      - name: Verify protected extensions installed
        timeout-minutes: 3
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Verifying protected extensions are installed..."
          flyctl ssh console --app $app_name --user developer --command "/bin/bash -lc '
            echo \"Checking mise availability...\"
            if command -v mise >/dev/null 2>&1; then
              echo \"‚úÖ mise available\"
              mise --version
            else
              echo \"‚ùå mise not found - mise-config installation may have failed\"
              exit 1
            fi

            echo \"\"
            echo \"Checking workspace structure...\"
            if [ -d /workspace ]; then
              echo \"‚úÖ /workspace directory exists\"
              ls -la /workspace | head -10
            else
              echo \"‚ùå /workspace directory missing\"
              exit 1
            fi
          '"

      - name: Test extension system with retry
        timeout-minutes: 10
        run: |
          source /tmp/retry_utils.sh

          echo "üîç Testing extension system..."

          # Test extension-manager availability
          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
            "/bin/bash -lc 'cd /workspace/scripts/lib && bash extension-manager.sh list'"; then
            echo "‚úÖ Extension manager available"
          else
            echo "‚ùå Extension manager not found"
            exit 1
          fi

          # Test extension installation (mise-config already installed from protected extensions)
          echo "üîç Testing extension installation with auto-activation (nodejs)..."
          if retry_with_backoff 3 10 60 \
            flyctl ssh console -a "${{ steps.app-name.outputs.app_name }}" --user developer \
              -C "/bin/bash -lc '
                cd /workspace/scripts/lib

                # Install with retry for mise-powered extensions
                if bash extension-manager.sh install nodejs 2>&1; then
                  echo \"‚úÖ Extensions installed\"
                else
                  echo \"‚ö†Ô∏è  Installation failed, checking mise status...\"
                  if command -v mise >/dev/null 2>&1; then
                    echo \"Running mise doctor for diagnostics:\"
                    mise doctor || true
                  else
                    echo \"mise not available (this is expected for non-mise extensions)\"
                  fi
                  exit 1
                fi
              '"; then
            echo "‚úÖ Extension installation with auto-activation successful"
          else
            echo "‚ùå Extension installation failed after retries"
            exit 1
          fi

          # Verify nodejs installation via mise
          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
            "/bin/bash -lc 'eval \"\$(mise activate bash)\" && command -v node && node --version'"; then
            echo "‚úÖ Extension validation successful (nodejs available via mise)"
          else
            echo "‚ùå Extension validation failed"
            exit 1
          fi

          # Verify mise is managing nodejs
          echo "üîç Verifying mise is managing nodejs..."
          if ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
            "/bin/bash -lc 'command -v mise >/dev/null 2>&1'"; then
            echo "‚úÖ mise is available, running diagnostics..."
            ssh_command_retry "${{ steps.app-name.outputs.app_name }}" \
              "/bin/bash -lc 'mise doctor'" || echo "‚ö†Ô∏è  mise doctor check completed with warnings"
          else
            echo "‚ÑπÔ∏è  mise not available (this is expected for current extension set)"
          fi

      - name: Cleanup test VM
        if: always()
        run: |
          source /tmp/retry_utils.sh

          echo "üßπ Cleaning up test VM..."

          if retry_with_backoff 3 5 30 \
            flyctl apps destroy "${{ steps.app-name.outputs.app_name }}" --yes; then
            echo "‚úÖ Test VM destroyed"
          else
            echo "‚ö†Ô∏è  Failed to destroy test VM (may require manual cleanup)"
          fi

      - name: Report test results
        if: always()
        run: |
          echo "üìä Test Summary"
          echo "=============="
          echo "App Name: ${{ steps.app-name.outputs.app_name }}"
          echo "Status: ${{ job.status }}"
          echo ""
          echo "All tests completed with comprehensive retry logic for:"
          echo "  - Flyctl deployments (4 attempts)"
          echo "  - SSH commands (5 attempts)"
          echo "  - Extension installations (3 attempts)"
          echo "  - Machine restarts (3 attempts)"
