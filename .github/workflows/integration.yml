name: Integration Tests

on:
  push:
    branches: [ main, develop ]
    paths:
      # Deployment configuration
      - 'fly.toml'
      - 'Dockerfile'
      # CI scripts
      - 'scripts/prepare-fly-config.sh'
      - 'scripts/lib/fly-common.sh'
      # Extension system
      - 'docker/lib/extensions.d/**'
      - 'docker/lib/extension-manager.sh'
      - 'docker/lib/common.sh'
      - 'docker/lib/extensions-common.sh'
      # Workflow itself
      - '.github/workflows/integration.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      # Deployment configuration
      - 'fly.toml'
      - 'Dockerfile'
      # CI scripts
      - 'scripts/prepare-fly-config.sh'
      - 'scripts/lib/fly-common.sh'
      # Extension system
      - 'docker/lib/extensions.d/**'
      - 'docker/lib/extension-manager.sh'
      - 'docker/lib/common.sh'
      - 'docker/lib/extensions-common.sh'
      # Workflow itself
      - '.github/workflows/integration.yml'
  workflow_dispatch:
    inputs:
      test_region:
        description: 'Fly.io region for test deployment'
        required: false
        default: 'sjc'
        type: string
      skip_cleanup:
        description: 'Skip cleanup (for debugging)'
        required: false
        default: false
        type: boolean

env:
  TEST_APP_PREFIX: "sindri-ci-test"
  REGION: ${{ inputs.test_region || 'sjc' }}
  FLY_API_TOKEN: ${{ secrets.FLYIO_AUTH_TOKEN }}

jobs:
  integration-test:
    name: End-to-End Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          # Generate unique app name with timestamp
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "Test app name: $app_name"

      - name: Create test SSH key
        id: ssh-key
        run: |
          # Generate SSH key for testing
          ssh-keygen -t ed25519 -f test_key -N "" -C "github-actions-test"
          echo "ssh_key_created=true" >> $GITHUB_OUTPUT

          # Set proper permissions
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "5"
          VM_MEMORY: "1024"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
          CI_MODE: "true"
        run: |
          # Use the configuration script in CI mode to prevent port conflicts
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          echo "Creating Fly.io app for testing..."

          # Create app
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || echo "App may already exist"

          # Create volume
          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 5 \
            --no-encryption \
            --yes

          # Set SSH key and CI mode as secrets
          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          # Deploy the application using immediate strategy to skip health checks
          # This prevents health check loops caused by port 22 conflicts with hallpass
          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 60s --yes

      - name: Wait for deployment
        run: |
          echo "Verifying deployment success..."

          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=120
          elapsed=0
          interval=10

          while [ $elapsed -lt $timeout ]; do
            # Get deployment status
            status_output=$(flyctl status --app $app_name 2>&1)

            echo "=== Status Check (${elapsed}s/${timeout}s) ==="
            echo "$status_output"

            # Check if machines are started (immediate deployment bypasses health checks)
            if echo "$status_output" | grep -q "started"; then
              echo "✅ Deployment successful - machine is started"
              break
            elif echo "$status_output" | grep -q "failed\|crashed\|error"; then
              echo "❌ Deployment failed"
              echo "App status: $status_output"
              echo "Recent logs:"
              flyctl logs --app $app_name
              exit 1
            else
              echo "Waiting for deployment to complete... (${elapsed}s/${timeout}s)"
            fi

            sleep $interval
            elapsed=$((elapsed + interval))
          done

          if [ $elapsed -ge $timeout ]; then
            echo "❌ Timeout waiting for deployment to complete"
            echo "Final status:"
            flyctl status --app $app_name
            echo "Recent logs:"
            flyctl logs --app $app_name
            exit 1
          fi

      - name: Test SSH connectivity
        run: |
          echo "Testing SSH connectivity..."

          app_name="${{ steps.app-name.outputs.app_name }}"
          max_attempts=5
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "SSH attempt $attempt/$max_attempts..."

            # Test SSH connection with timeout using flyctl
            if timeout 30 flyctl ssh console --app $app_name --command "/bin/bash -c 'echo \"SSH connection successful\" && whoami && pwd'" 2>/dev/null; then
              echo "✅ SSH connection successful"
              break
            else
              echo "⚠️  SSH attempt $attempt failed"
              if [ $attempt -eq $max_attempts ]; then
                echo "❌ All SSH attempts failed"

                # Debug information
                echo "App status:"
                flyctl status --app $app_name
                echo "App logs:"
                flyctl logs --app $app_name
                exit 1
              fi

              sleep 30
            fi

            attempt=$((attempt + 1))
          done

      - name: Test VM configuration and extension system
        run: |
          echo "Testing VM configuration, tools, and extension system..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          # Test that configuration script and extension system exists
          flyctl ssh console --app $app_name --command '
            echo "Testing VM environment..."

            # Check extension manager
            if [ -f "/workspace/scripts/lib/extension-manager.sh" ]; then
              echo "✅ Extension manager found"
            else
              echo "❌ Extension manager missing"
              exit 1
            fi

            # Check for extension examples
            if [ -d "/workspace/scripts/lib/extensions.d" ]; then
              ext_count=$(ls -1 /workspace/scripts/lib/extensions.d/*.extension 2>/dev/null | wc -l)
              echo "✅ Extension directory found with $ext_count extension examples"
            else
              echo "❌ Extensions directory missing"
              exit 1
            fi

            # Check basic tools
            which curl || { echo "❌ curl not found"; exit 1; }
            which git || { echo "❌ git not found"; exit 1; }
            which ssh || { echo "❌ ssh not found"; exit 1; }

            # Check workspace directory
            ls -la /workspace/ || { echo "❌ workspace directory issue"; exit 1; }

            echo "✅ Basic VM tests passed"
            '

      - name: Verify volume mount
        run: |
          echo "Verifying volume mount..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          # Check volume mount and permissions
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            echo \"=== Volume Mount Verification ===\"
            echo \"Checking /workspace mount:\"
            df -h /workspace || echo \"WARNING: df command failed\"
            echo \"\"
            echo \"Workspace directory contents:\"
            ls -la /workspace/ || echo \"WARNING: ls command failed\"
            echo \"\"
            echo \"Mount information:\"
            mount | grep workspace || echo \"WARNING: No workspace mount found in mount output\"
            echo \"\"
            echo \"Workspace permissions:\"
            stat /workspace/ || echo \"WARNING: stat command failed\"
            echo \"\"
            echo \"Testing write permissions:\"
            touch /workspace/mount-test-$(date +%s).tmp && echo \"✅ Write permission confirmed\" || echo \"❌ Write permission failed\"
            echo \"=== End Volume Mount Verification ===\"
            '"

      - name: Test volume persistence
        run: |
          echo "Testing volume persistence..."

          app_name="${{ steps.app-name.outputs.app_name }}"
          test_file="/workspace/test-persistence-$(date +%s).txt"
          test_content="integration-test-$(date +%s)"

          # Create test file with explicit sync operations
          echo "Creating test file with content: $test_content"
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            echo \"Creating and syncing test file...\"
            echo \"$test_content\" > $test_file
            sync
            sleep 2
            echo \"Verifying file was written correctly...\"
            if [ -f \"$test_file\" ]; then
              file_size=\$(wc -c < \"$test_file\")
              echo \"File created with size: \$file_size bytes\"
              cat \"$test_file\"
            else
              echo \"ERROR: File was not created\"
              exit 1
            fi
          '"

          # Force filesystem sync before restart
          echo "Forcing filesystem sync before restart..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            echo \"Syncing filesystem before restart...\"
            sync
            echo \"Sync completed\"
            sleep 3
            echo \"Final file verification before restart:\"
            ls -la \"$test_file\" 2>/dev/null || echo \"File not found\"
            wc -c \"$test_file\" 2>/dev/null || echo \"Cannot get file size\"
            cat \"$test_file\" 2>/dev/null || echo \"Cannot read file\"
          '"

          # Wait additional time for any remaining buffer flushes
          echo "Waiting for buffer flush before restart..."
          sleep 10

          # Restart the machine to test persistence
          echo "Restarting machine to test persistence..."
          machine_id=$(flyctl machine list --app $app_name --json | jq -r '.[0].id')
          flyctl machine restart $machine_id --app $app_name

          # Wait for restart and ensure machine is ready
          echo "Waiting for machine to restart and become ready..."
          sleep 45

          # Verify machine is running
          max_attempts=5
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Checking machine status (attempt $attempt/$max_attempts)..."
            if flyctl status --app $app_name | grep -q "started"; then
              echo "✅ Machine is running"
              break
            else
              echo "⚠️  Machine not ready, waiting..."
              sleep 10
              attempt=$((attempt + 1))
            fi
          done

          if [ $attempt -gt $max_attempts ]; then
            echo "❌ Machine failed to start after restart"
            exit 1
          fi

          # Test volume persistence with retry logic
          echo "Testing file persistence after restart..."
          max_attempts=3
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            echo "Persistence test attempt $attempt/$max_attempts..."

            # Enhanced file verification with metadata
            echo "Performing comprehensive file verification..."

            verification_result=$(flyctl ssh console --app $app_name --command "/bin/bash -c '
              echo \"=== Post-Restart File Verification ===\"
              if [ -f \"$test_file\" ]; then
                echo \"✅ File exists\"
                echo \"File metadata:\"
                ls -la \"$test_file\"
                echo \"File size: \$(wc -c < \"$test_file\") bytes\"
                echo \"File content:\"
                content=\$(cat \"$test_file\" 2>/dev/null)
                if [ -n \"\$content\" ]; then
                  echo \"\$content\"
                  echo \"VERIFICATION_STATUS=SUCCESS\"
                else
                  echo \"[EMPTY FILE]\"
                  echo \"VERIFICATION_STATUS=EMPTY\"
                fi
              else
                echo \"❌ File missing\"
                echo \"VERIFICATION_STATUS=MISSING\"
              fi
              echo \"=== End Verification ===\"
            '")

            echo "$verification_result"

            if echo "$verification_result" | grep -q "VERIFICATION_STATUS=SUCCESS"; then
              echo "✅ Test file exists with content after restart"

              # Extract and verify content
              actual_content=$(echo "$verification_result" | grep -A 1 "File content:" | tail -1)

              if [ "$actual_content" = "$test_content" ]; then
                echo "✅ Volume persistence test passed - content matches perfectly"
                break
              else
                echo "❌ File content mismatch:"
                echo "  Expected: '$test_content'"
                echo "  Actual:   '$actual_content'"
                echo "  Expected length: ${#test_content}"
                echo "  Actual length:   ${#actual_content}"
                exit 1
              fi
            elif echo "$verification_result" | grep -q "VERIFICATION_STATUS=EMPTY"; then
              echo "⚠️  File exists but is empty (attempt $attempt/$max_attempts)"
              echo "This indicates a filesystem sync issue during restart"
              if [ $attempt -eq $max_attempts ]; then
                echo "❌ File content lost after restart - filesystem sync failure"
                echo "Debugging information:"
                echo "$verification_result"
                exit 1
              fi
            else
              echo "⚠️  Test file not found (attempt $attempt/$max_attempts)"
              if [ $attempt -eq $max_attempts ]; then
                echo "❌ Test file disappeared after restart"
                echo "Debugging - workspace contents:"
                flyctl ssh console --app $app_name --command "/bin/bash -c 'ls -la /workspace/ | head -20'"
                exit 1
              fi
            fi

            sleep 10
            attempt=$((attempt + 1))
          done

      - name: Test auto-suspend functionality
        if: success()
        run: |
          echo "Testing auto-suspend functionality..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          # Check that machine can be suspended
          machine_id=$(flyctl machine list --app $app_name --json | jq -r '.[0].id')

          if [ -z "$machine_id" ] || [ "$machine_id" = "null" ]; then
            echo "❌ Failed to get machine ID"
            exit 1
          fi

          echo "Stopping machine $machine_id..."
          if ! flyctl machine stop $machine_id --app $app_name 2>&1; then
            echo "⚠️  Machine stop command failed, may already be stopped"
          fi

          # Wait for stop
          sleep 10

          # Check status
          if flyctl status --app $app_name 2>&1 | grep -q "stopped"; then
            echo "✅ Auto-suspend test passed - machine stopped"
          else
            echo "⚠️  Machine did not show stopped status, but continuing..."
          fi

          # Start it back up for cleanup
          echo "Starting machine $machine_id..."
          if ! flyctl machine start $machine_id --app $app_name 2>&1; then
            echo "❌ Failed to start machine"
            flyctl status --app $app_name
            exit 1
          fi

          # Wait for machine to fully restart with verification
          echo "Waiting for machine to restart..."
          sleep 30

          # Verify machine is running before proceeding to cleanup
          max_attempts=8
          attempt=1
          machine_started=false

          while [ $attempt -le $max_attempts ]; do
            echo "Checking machine status (attempt $attempt/$max_attempts)..."

            status_output=$(flyctl status --app $app_name 2>&1 || echo "status_failed")

            if echo "$status_output" | grep -q "started"; then
              echo "✅ Machine fully restarted and ready for cleanup"
              machine_started=true
              break
            elif echo "$status_output" | grep -q "status_failed"; then
              echo "⚠️  Status check failed, retrying..."
            else
              echo "⚠️  Machine not ready yet (status: $(echo "$status_output" | grep -oE 'stopped|starting|started|stopping' | head -1)), waiting..."
            fi

            sleep 10
            attempt=$((attempt + 1))
          done

          if [ "$machine_started" = "false" ]; then
            echo "❌ Machine failed to start after $max_attempts attempts"
            echo "Final status:"
            flyctl status --app $app_name
            echo "Machine logs:"
            flyctl logs --app $app_name
            exit 1
          fi

      - name: Test basic extension workflow
        if: success()
        run: |
          echo "Testing basic extension installation with auto-activation..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib

            echo \"=== Testing Extension Manager Workflow ===\"

            # Test listing extensions
            echo \"\"
            echo \"Available extensions:\"
            bash extension-manager.sh list

            # Test installing workspace-structure extension (auto-activates)
            echo \"\"
            echo \"Installing workspace-structure extension (with auto-activation)...\"
            if bash extension-manager.sh install workspace-structure; then
              echo \"✅ Extension installed and activated\"
            else
              echo \"❌ Extension installation failed\"
              exit 1
            fi

            # Verify extension was activated (check for .sh file without .example)
            echo \"\"
            echo \"Checking extension activation...\"
            if [ -f extensions.d/workspace-structure.sh ]; then
              echo \"✅ Extension file activated (copied from .example)\"
            else
              echo \"❌ Extension file not activated\"
              exit 1
            fi

            # Check extension status
            echo \"\"
            echo \"Checking extension status...\"
            bash extension-manager.sh status workspace-structure

            echo \"\"
            echo \"✅ Basic extension workflow test passed\"
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          echo "Cleaning up test resources..."

          app_name="${{ steps.app-name.outputs.app_name }}"

          # Stop and destroy machines
          machines=$(flyctl machine list --app $app_name --json | jq -r '.[].id')
          for machine in $machines; do
            echo "Stopping machine $machine..."
            flyctl machine stop $machine --app $app_name || true
            sleep 5
            echo "Destroying machine $machine..."
            flyctl machine destroy $machine --app $app_name --force || true
          done

          # Destroy volumes
          volumes=$(flyctl volumes list --app $app_name --json | jq -r '.[].id')
          for volume in $volumes; do
            echo "Destroying volume $volume..."
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          # Destroy app
          echo "Destroying app $app_name..."
          flyctl apps destroy $app_name --yes || true

          # Clean up SSH key
          rm -f test_key test_key.pub

          echo "✅ Cleanup completed"

      - name: Report test results
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "✅ All integration tests passed successfully"
            echo "## ✅ Integration Tests Passed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All end-to-end integration tests completed successfully!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Validated" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ VM deployment and configuration" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ SSH connectivity (Fly.io hallpass)" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Volume persistence across restarts" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Extension system presence and basic workflow" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Auto-suspend functionality" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Some integration tests failed"
            echo "Check the logs above for details"
            echo "## ❌ Integration Tests Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Some integration tests failed. Review the job logs for detailed error information." >> $GITHUB_STEP_SUMMARY
          fi

  developer-workflow:
    name: Developer Workflow Integration
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read
    # Only run on workflow_dispatch or when explicitly requested
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, '[test-workflow]')

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-workflow-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "Test app name: $app_name"

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "workflow-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "10"
          VM_MEMORY: "2048"
          CPU_KIND: "shared"
          CPU_COUNT: "1"
          CI_MODE: "true"
        run: |
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          echo "Creating Fly.io app for workflow testing..."
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || echo "App may already exist"

          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 10 \
            --no-encryption \
            --yes

          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 90s --yes

      - name: Wait for deployment
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=180
          elapsed=0
          interval=10

          while [ $elapsed -lt $timeout ]; do
            status_output=$(flyctl status --app $app_name 2>&1)
            if echo "$status_output" | grep -q "started"; then
              echo "✅ Deployment successful"
              sleep 30
              break
            fi
            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Add core extensions to manifest
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Setting up manifest with protected core extensions..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib
            manifest_file=\"extensions.d/active-extensions.conf\"

            # Create manifest from CI template (already has protected extensions)
            if [ ! -f \"\$manifest_file\" ]; then
              cp extensions.d/active-extensions.ci.conf \"\$manifest_file\" 2>/dev/null || touch \"\$manifest_file\"
            fi

            echo \"\"
            echo \"=== Protected Extensions in Manifest (from CI config) ===\"
            grep -v \"^[[:space:]]*#\" \"\$manifest_file\" | grep -v \"^[[:space:]]*$\" || echo \"(empty)\"

            # Verify protected extensions are present
            echo \"\"
            echo \"Verifying protected extensions...\"
            for ext in workspace-structure mise-config ssh-environment; do
              if grep -q \"^\$ext\$\" \"\$manifest_file\"; then
                echo \"✅ \$ext present in manifest\"
              else
                echo \"❌ \$ext missing from CI config - this should not happen\"
                exit 1
              fi
            done
          '"

      - name: Install all extensions from manifest
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Installing all activated extensions..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib

            echo \"Running install-all...\"
            if bash extension-manager.sh install-all; then
              echo \"✅ All extensions installed\"
            else
              echo \"❌ Extension installation failed\"
              exit 1
            fi
          '"

      - name: Verify all extensions installed correctly
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Verifying extension installations..."
          flyctl ssh console --app $app_name --command "/bin/bash -lc '
            # Source SSH environment
            if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
              source /etc/profile.d/00-ssh-environment.sh
            fi

            echo \"=== Verification ===\"

            # Verify workspace structure
            if [ -d /workspace/src ] && [ -d /workspace/tests ]; then
              echo \"✅ Workspace structure created\"
            else
              echo \"❌ Workspace structure missing\"
              exit 1
            fi

            # Verify Node.js
            if command -v node >/dev/null 2>&1; then
              echo \"✅ Node.js installed: \$(node --version)\"
            else
              echo \"❌ Node.js not found\"
              exit 1
            fi

            # Verify SSH environment
            if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
              echo \"✅ SSH environment configured\"
            else
              echo \"❌ SSH environment not configured\"
              exit 1
            fi

            echo \"\"
            echo \"✅ All extensions verified\"
          '"

      - name: Test extension status command
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing extension status command..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib

            for ext in workspace-structure nodejs ssh-environment; do
              echo \"\"
              echo \"Checking status of \$ext...\"
              if bash extension-manager.sh status \$ext; then
                echo \"✅ Status command works for \$ext\"
              else
                echo \"⚠️  Status command failed for \$ext\"
              fi
            done
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 3
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  mise-stack-integration:
    name: mise-Stack Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 60
    permissions:
      contents: read
    # Only run on workflow_dispatch or when explicitly requested
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, '[test-mise-stack]')

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Install Fly CLI
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Generate test app name
        id: app-name
        run: |
          timestamp=$(date +%s)
          app_name="${TEST_APP_PREFIX}-mise-${timestamp}"
          echo "app_name=$app_name" >> $GITHUB_OUTPUT
          echo "Test app name: $app_name"

      - name: Create test SSH key
        run: |
          ssh-keygen -t ed25519 -f test_key -N "" -C "mise-test"
          chmod 600 test_key
          chmod 644 test_key.pub

      - name: Prepare fly.toml for testing
        env:
          APP_NAME: ${{ steps.app-name.outputs.app_name }}
          VOLUME_NAME: "test_data"
          VOLUME_SIZE: "15"
          VM_MEMORY: "4096"
          CPU_KIND: "performance"
          CPU_COUNT: "2"
          CI_MODE: "true"
        run: |
          ./scripts/prepare-fly-config.sh --ci-mode

      - name: Deploy test environment
        run: |
          echo "Creating Fly.io app for mise-stack testing..."
          flyctl apps create ${{ steps.app-name.outputs.app_name }} --org personal || echo "App may already exist"

          flyctl volumes create test_data \
            --app ${{ steps.app-name.outputs.app_name }} \
            --region ${REGION} \
            --size 15 \
            --no-encryption \
            --yes

          ssh_key_content=$(cat test_key.pub)
          flyctl secrets set AUTHORIZED_KEYS="$ssh_key_content" \
            --app ${{ steps.app-name.outputs.app_name }}
          flyctl secrets set CI_MODE="true" \
            --app ${{ steps.app-name.outputs.app_name }}

          flyctl deploy --app ${{ steps.app-name.outputs.app_name }} --strategy immediate --wait-timeout 120s --yes

      - name: Wait for deployment
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"
          timeout=240
          elapsed=0
          interval=15

          while [ $elapsed -lt $timeout ]; do
            status_output=$(flyctl status --app $app_name 2>&1)
            if echo "$status_output" | grep -q "started"; then
              echo "✅ Deployment successful"
              sleep 30
              break
            fi
            sleep $interval
            elapsed=$((elapsed + interval))
          done

      - name: Add mise-stack extensions to manifest
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Adding mise-stack extensions to manifest..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib
            manifest_file=\"extensions.d/active-extensions.conf\"

            # Create manifest from CI template (already has protected extensions)
            if [ ! -f \"\$manifest_file\" ]; then
              cp extensions.d/active-extensions.ci.conf \"\$manifest_file\" 2>/dev/null || touch \"\$manifest_file\"
            fi

            # Verify protected extensions are present
            echo \"Verifying protected extensions from CI config...\"
            for ext in workspace-structure mise-config ssh-environment; do
              if grep -q \"^\$ext\$\" \"\$manifest_file\"; then
                echo \"✅ \$ext present\"
              else
                echo \"❌ \$ext missing from CI config\"
                exit 1
              fi
            done

            # Add additional mise-stack extensions (skip protected ones already in CI conf)
            echo \"\"
            echo \"Adding additional mise-stack extensions...\"
            for ext in nodejs python rust golang; do
              if ! grep -q \"^\$ext\$\" \"\$manifest_file\" 2>/dev/null; then
                echo \"\$ext\" >> \"\$manifest_file\"
                echo \"✅ \$ext added to manifest\"
              else
                echo \"✅ \$ext already in manifest\"
              fi
            done

            echo \"\"
            echo \"=== Extensions in Manifest ===\"
            grep -v \"^[[:space:]]*#\" \"\$manifest_file\" | grep -v \"^[[:space:]]*$\" || echo \"(empty)\"
          '"

      - name: Install all mise-stack extensions
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Installing all mise-stack extensions..."
          flyctl ssh console --app $app_name --command "/bin/bash -c '
            cd /workspace/scripts/lib

            echo \"Running install-all for mise-stack...\"
            if bash extension-manager.sh install-all; then
              echo \"✅ All mise-stack extensions installed\"
            else
              echo \"❌ Extension installation failed\"
              exit 1
            fi
          '"

      - name: Test mise-stack cross-extension functionality
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          echo "Testing mise-stack cross-extension functionality..."

          flyctl ssh console --app $app_name --command "/bin/bash -lc '
            # Source SSH environment for non-interactive sessions
            if [ -f /etc/profile.d/00-ssh-environment.sh ]; then
              source /etc/profile.d/00-ssh-environment.sh
            fi

            echo \"Testing mise-Powered Language Stack...\"

            # Verify mise is installed
            if ! command -v mise >/dev/null 2>&1; then
              echo \"❌ mise not installed\"
              exit 1
            fi
            echo \"✅ mise: \$(mise --version)\"

            # Show all mise-managed tools
            echo \"\"
            echo \"mise-managed tools:\"
            mise ls

            # Test Node.js
            echo \"\"
            echo \"Testing Node.js (via mise)...\"
            node --version && npm --version
            mise ls node && echo \"✅ Node.js managed by mise\"

            # Test Python
            echo \"\"
            echo \"Testing Python (via mise)...\"
            python3 --version
            mise ls python && echo \"✅ Python managed by mise\"

            # Test Rust
            echo \"\"
            echo \"Testing Rust (via mise)...\"
            rustc --version && cargo --version
            mise ls rust && echo \"✅ Rust managed by mise\"

            # Test Go
            echo \"\"
            echo \"Testing Go (via mise)...\"
            go version
            mise ls go && echo \"✅ Go managed by mise\"

            echo \"\"
            echo \"✅ mise-powered language stack verified\"
          '"

      - name: Cleanup test resources
        if: always() && !inputs.skip_cleanup
        run: |
          app_name="${{ steps.app-name.outputs.app_name }}"

          machines=$(flyctl machine list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for machine in $machines; do
            [[ -z "$machine" ]] && continue
            flyctl machine stop $machine --app $app_name || true
            sleep 3
            flyctl machine destroy $machine --app $app_name --force || true
          done

          volumes=$(flyctl volumes list --app $app_name --json 2>/dev/null | jq -r '.[].id' || echo "")
          for volume in $volumes; do
            [[ -z "$volume" ]] && continue
            flyctl volumes destroy $volume --app $app_name --yes || true
          done

          flyctl apps destroy $app_name --yes || true
          rm -f test_key test_key.pub

  notify-failure:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [integration-test, developer-workflow, mise-stack-integration]
    if: failure() && github.event_name == 'schedule'
    permissions:
      contents: read
      issues: write

    steps:
      - name: Create failure issue
        uses: actions/github-script@v8
        with:
          script: |
            const title = `Integration Tests Failed - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            🚨 **Scheduled Integration Tests Failed**

            The daily integration tests have failed. Please investigate the following:

            - Check the [workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - Verify Fly.io infrastructure is working
            - Check if any recent changes broke the deployment process

            **Details:**
            - Run ID: ${{ github.run_id }}
            - Triggered: ${{ github.event_name }}
            - Time: ${new Date().toISOString()}

            This issue was automatically created by the integration test workflow.
            `;

            // Check if an issue already exists for today
            const today = new Date().toISOString().split('T')[0];
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'integration-test-failure'
            });

            const existingIssue = issues.data.find(issue =>
              issue.title.includes(today) && issue.title.includes('Integration Tests Failed')
            );

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['bug', 'integration-test-failure', 'high-priority']
              });
            } else {
              // Add a comment to the existing issue with new failure details
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `
                🔄 **Additional Integration Test Failure**

                Another integration test run has failed today.

                **Details:**
                - Run ID: ${{ github.run_id }}
                - Time: ${new Date().toISOString()}
                - Workflow: [View Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
                `
              });
            }