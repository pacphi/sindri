name: "v3: Release"

# v3 Rust Binary Release Pipeline
# Triggers on tags matching v3.*.* (e.g., v3.0.0, v3.1.0-alpha.1)

on:
  push:
    tags:
      - "v3.*.*"

env:
  CARGO_TERM_COLOR: always

jobs:
  # Job 1: Validate the release tag format and detect prerelease
  validate-tag:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      is_prerelease: ${{ steps.validate.outputs.is_prerelease }}
    steps:
      - name: Validate semantic version tag
        id: validate
        run: |
          tag_name="${GITHUB_REF#refs/tags/}"
          echo "Tag name: $tag_name"

          # Validate format: v3.0.0 or v3.0.0-alpha.1
          if [[ ! $tag_name =~ ^v3\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "::error::Invalid tag format: $tag_name"
            echo "Tag must match pattern: v3.{MINOR}.{PATCH} or v3.{MINOR}.{PATCH}-{prerelease}"
            exit 1
          fi

          # Extract version without 'v' prefix
          version="${tag_name#v}"
          echo "version=$version" >> "$GITHUB_OUTPUT"

          # Detect prerelease (alpha, beta, rc)
          if [[ $version =~ -[a-zA-Z] ]]; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "Detected prerelease version: $version"
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
            echo "Detected stable version: $version"
          fi

  # Job 2: Generate changelog from commits since last tag
  generate-changelog:
    runs-on: ubuntu-latest
    needs: validate-tag
    outputs:
      changelog: ${{ steps.changelog.outputs.changelog }}
      changelog_file: ${{ steps.changelog.outputs.changelog_file }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Generate changelog using consolidated script
        id: changelog
        run: |
          version="${{ needs.validate-tag.outputs.version }}"

          # Use consolidated changelog generation script
          ./.github/scripts/generate-changelog.sh "$version" "v3" "v3/" "changelog.md"

          # Output for GitHub Actions (escape newlines)
          changelog=$(cat changelog.md)
          {
            echo "changelog<<CHANGELOG_EOF"
            echo "$changelog"
            echo "CHANGELOG_EOF"
          } >> "$GITHUB_OUTPUT"

          echo "changelog_file=changelog.md" >> "$GITHUB_OUTPUT"

      - name: Upload changelog artifact
        uses: actions/upload-artifact@v6
        with:
          name: changelog-v3
          path: changelog.md

  # Job 3: Build release binaries for multiple platforms
  build-binaries:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    needs: validate-tag
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: linux-x86_64

          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            platform: linux-aarch64
            cross: true

          - os: macos-latest
            target: aarch64-apple-darwin
            platform: macos-aarch64

          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: windows-x86_64

    steps:
      - uses: actions/checkout@v6

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools
        if: matrix.cross
        run: |
          cargo install cross --git https://github.com/cross-rs/cross

      - name: Cache Cargo dependencies
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            v3/target/
          key: ${{ runner.os }}-cargo-release-${{ matrix.target }}-${{ hashFiles('v3/**/Cargo.lock') }}

      - name: Build release binary
        run: |
          cd v3

          if [[ "${{ matrix.cross }}" == "true" ]]; then
            cross build --release --target ${{ matrix.target }}
          else
            cargo build --release --target ${{ matrix.target }}
          fi
        shell: bash

      - name: Package binary (Unix)
        if: runner.os != 'Windows'
        run: |
          version="${{ needs.validate-tag.outputs.version }}"
          cd v3/target/${{ matrix.target }}/release

          if [[ -f sindri ]]; then
            tar -czf sindri-v$version-${{ matrix.platform }}.tar.gz sindri
            mv sindri-v$version-${{ matrix.platform }}.tar.gz $GITHUB_WORKSPACE/
          fi
        shell: bash

      - name: Package binary (Windows)
        if: runner.os == 'Windows'
        run: |
          $version = "${{ needs.validate-tag.outputs.version }}"
          cd v3/target/${{ matrix.target }}/release

          if (Test-Path sindri.exe) {
            Compress-Archive -Path sindri.exe -DestinationPath "sindri-v$version-${{ matrix.platform }}.zip"
            Move-Item "sindri-v$version-${{ matrix.platform }}.zip" $env:GITHUB_WORKSPACE/
          }
        shell: pwsh

      - name: Upload binary artifact
        uses: actions/upload-artifact@v6
        with:
          name: binary-${{ matrix.platform }}
          path: |
            sindri-*.tar.gz
            sindri-*.zip
          retention-days: 1

  # Job 4: Verify CI image exists for promotion
  verify-ci-image:
    runs-on: ubuntu-latest
    needs: validate-tag
    permissions:
      contents: read
      packages: read
    outputs:
      ci_image: ${{ steps.verify.outputs.ci_image }}
      image_digest: ${{ steps.verify.outputs.image_digest }}
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Get commit SHA for tag
        id: get-sha
        run: |
          SHA=$(git rev-parse HEAD)
          echo "sha=$SHA" >> $GITHUB_OUTPUT
          echo "Tag ${{ github.ref_name }} points to commit: $SHA"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for CI image
        id: verify
        run: |
          SHA="${{ steps.get-sha.outputs.sha }}"
          CI_PASSED="ghcr.io/${{ github.repository }}:v3-ci-passed-${SHA}"
          CI_TAG="ghcr.io/${{ github.repository }}:v3-ci-${SHA}"

          echo "Looking for promotion candidate images..."
          echo "  Preferred: $CI_PASSED"
          echo "  Fallback:  $CI_TAG"
          echo ""

          if docker pull "$CI_PASSED" 2>/dev/null; then
            echo "ci_image=$CI_PASSED" >> $GITHUB_OUTPUT
            DIGEST=$(docker inspect "$CI_PASSED" --format='{{index .RepoDigests 0}}')
            echo "image_digest=$DIGEST" >> $GITHUB_OUTPUT
            echo "‚úÖ Found CI image: $CI_PASSED"
            echo "   Digest: $DIGEST"
            echo "::notice title=CI Image Found::Using tested image: $CI_PASSED"
          elif docker pull "$CI_TAG" 2>/dev/null; then
            echo "ci_image=$CI_TAG" >> $GITHUB_OUTPUT
            DIGEST=$(docker inspect "$CI_TAG" --format='{{index .RepoDigests 0}}')
            echo "image_digest=$DIGEST" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Using unverified CI image: $CI_TAG"
            echo "   Digest: $DIGEST"
            echo "::warning title=Unverified CI Image::Using CI image that didn't pass tests: $CI_TAG"
          else
            echo "::error title=No CI Image::No CI image found for commit $SHA"
            echo ""
            echo "Possible causes:"
            echo "  1. CI workflow didn't run on this commit"
            echo "  2. CI workflow is still running"
            echo "  3. CI workflow failed"
            echo "  4. Image was deleted (check retention policy)"
            echo ""
            echo "To fix:"
            echo "  1. Verify CI ran: https://github.com/${{ github.repository }}/actions"
            echo "  2. Check GHCR packages: https://github.com/${{ github.repository }}/pkgs/container/${{ github.event.repository.name }}"
            exit 1
          fi

  # Job 5: Promote CI image to release (no rebuild!)
  promote-image:
    runs-on: ubuntu-latest
    needs: [validate-tag, verify-ci-image]
    permissions:
      contents: read
      packages: write
    env:
      # Set env vars for conditionals (secrets can't be used directly in if:)
      DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
    outputs:
      tags: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Login to Docker Hub (optional)
        if: env.DOCKERHUB_TOKEN != ''
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Determine image list
        id: images
        run: |
          IMAGES="ghcr.io/${{ github.repository }}"
          if [[ -n "$DOCKERHUB_USERNAME" ]]; then
            IMAGES="${IMAGES}"$'\n'"${DOCKERHUB_USERNAME}/sindri"
          fi
          echo "list<<EOF" >> $GITHUB_OUTPUT
          echo "$IMAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate release tags
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.images.outputs.list }}
          tags: |
            type=semver,pattern={{version}},value=v${{ needs.validate-tag.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=v${{ needs.validate-tag.outputs.version }}
            type=semver,pattern={{major}},value=v${{ needs.validate-tag.outputs.version }},enable=${{ needs.validate-tag.outputs.is_prerelease == 'false' }}
            type=raw,value=v3,enable=${{ needs.validate-tag.outputs.is_prerelease == 'false' }}
            type=raw,value=v3-latest,enable=${{ needs.validate-tag.outputs.is_prerelease == 'false' }}
            type=raw,value=latest,enable=${{ needs.validate-tag.outputs.is_prerelease == 'false' }}
          labels: |
            org.opencontainers.image.title=Sindri v3
            org.opencontainers.image.description=Multi-cloud development environment orchestrator (Rust)
            org.opencontainers.image.version=${{ needs.validate-tag.outputs.version }}
            sindri.version=v3
            sindri.release.promoted-from=${{ needs.verify-ci-image.outputs.ci_image }}

      - name: Pull and retag CI image
        run: |
          CI_IMAGE="${{ needs.verify-ci-image.outputs.ci_image }}"
          echo "Pulling CI image: $CI_IMAGE"
          docker pull "$CI_IMAGE"

          # Parse tags output (newline-separated list)
          TAGS="${{ steps.meta.outputs.tags }}"

          echo ""
          echo "Retagging for release:"
          while IFS= read -r TAG; do
            [[ -z "$TAG" ]] && continue
            echo "  ‚Üí $TAG"
            docker tag "$CI_IMAGE" "$TAG"
          done <<< "$TAGS"

          echo ""
          echo "Pushing release tags:"
          while IFS= read -r TAG; do
            [[ -z "$TAG" ]] && continue

            # Check if pushing to Docker Hub and if credentials are available
            if [[ "$TAG" =~ ^docker\.io/ ]] && [[ -z "$DOCKERHUB_USERNAME" ]]; then
              echo "  ‚è≠Ô∏è  Skipping $TAG (Docker Hub credentials not configured)"
              continue
            fi

            echo "  ‚Üí $TAG"
            if docker push "$TAG"; then
              echo "    ‚úÖ Pushed successfully"
            else
              echo "    ‚ö†Ô∏è  Push failed (non-fatal)"
            fi
          done <<< "$TAGS"

          echo ""
          echo "‚úÖ Image promotion complete"
          echo "   Source:  $CI_IMAGE"
          echo "   Digest:  ${{ needs.verify-ci-image.outputs.image_digest }}"

  # Job 6: Sign images with Cosign 3.x (keyless)
  sign-image:
    runs-on: ubuntu-latest
    needs: [validate-tag, verify-ci-image, promote-image]
    permissions:
      contents: read
      packages: write
      id-token: write  # Required for OIDC keyless signing
      attestations: write  # Required for provenance attestation
    steps:
      - name: Install Cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get image digest
        id: digest
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          REPO="${{ github.repository }}"
          IMAGE="ghcr.io/${REPO}:${VERSION}"

          # Get the digest for the version tag (all tags point to same digest)
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE" 2>/dev/null || true)

          if [[ -z "$DIGEST" ]]; then
            # Pull first if not available locally
            docker pull "$IMAGE"
            DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE")
          fi

          # Extract just the sha256:... part
          DIGEST_HASH="${DIGEST#*@}"
          echo "digest=$DIGEST_HASH" >> $GITHUB_OUTPUT
          echo "Image digest: $DIGEST_HASH"

      - name: Sign image by digest
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          REPO="${{ github.repository }}"
          DIGEST="${{ steps.digest.outputs.digest }}"

          echo "Signing release image by digest with Cosign 3.x (keyless)..."
          echo "  Image: ghcr.io/${REPO}@${DIGEST}"
          echo ""

          # Best practice: sign by digest (immutable) rather than tag (mutable)
          cosign sign --yes "ghcr.io/${REPO}@${DIGEST}"

          echo ""
          echo "‚úÖ Image signed successfully (by digest)"
          echo ""
          echo "Verify with:"
          echo "  cosign verify ghcr.io/${REPO}:${VERSION} \\"
          echo "    --certificate-identity-regexp='https://github.com/${{ github.repository }}' \\"
          echo "    --certificate-oidc-issuer='https://token.actions.githubusercontent.com'"

  # Job 7: Attest build provenance (SLSA)
  attest-provenance:
    runs-on: ubuntu-latest
    needs: [validate-tag, verify-ci-image, promote-image]
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get image digest
        id: digest
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          IMAGE="ghcr.io/${{ github.repository }}:${VERSION}"

          docker pull "$IMAGE"
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE")
          DIGEST_HASH="${DIGEST#*@}"
          echo "digest=$DIGEST_HASH" >> $GITHUB_OUTPUT
          echo "Image digest: $DIGEST_HASH"

      - name: Attest build provenance
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ghcr.io/${{ github.repository }}
          subject-digest: ${{ steps.digest.outputs.digest }}
          push-to-registry: true

  # Job 8: Generate and attach SBOM
  generate-sbom:
    runs-on: ubuntu-latest
    needs: [validate-tag, verify-ci-image, promote-image]
    permissions:
      contents: read
      packages: write
      id-token: write  # Required for cosign 3.x keyless operations
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Get image digest
        id: digest
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          IMAGE="ghcr.io/${{ github.repository }}:${VERSION}"

          docker pull "$IMAGE"
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$IMAGE")
          DIGEST_HASH="${DIGEST#*@}"
          echo "digest=$DIGEST_HASH" >> $GITHUB_OUTPUT

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ghcr.io/${{ github.repository }}:${{ needs.validate-tag.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Attach SBOM to image
        run: |
          REPO="${{ github.repository }}"
          DIGEST="${{ steps.digest.outputs.digest }}"

          echo "Attaching SBOM to image by digest..."
          cosign attach sbom --sbom sbom.spdx.json "ghcr.io/${REPO}@${DIGEST}"

          echo "‚úÖ SBOM attached successfully"
          echo ""
          echo "Download with:"
          echo "  cosign download sbom ghcr.io/${REPO}:${{ needs.validate-tag.outputs.version }}"

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v6
        with:
          name: sbom-v${{ needs.validate-tag.outputs.version }}
          path: sbom.spdx.json
          retention-days: 90

  # Job 8: Update CHANGELOG.md and Cargo.toml
  update-version-files:
    runs-on: ubuntu-latest
    needs: [validate-tag, generate-changelog]
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6
        with:
          ref: main
          fetch-depth: 0

      - name: Download changelog artifact
        uses: actions/download-artifact@v7
        with:
          name: changelog-v3

      - name: Update v3/CHANGELOG.md
        run: |
          version="${{ needs.validate-tag.outputs.version }}"
          changelog_header='# Changelog - Sindri v3

          All notable changes to Sindri v3 (Rust) will be documented in this file.

          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

          <!-- Entries below are auto-generated by release workflow -->'

          # Create v3/CHANGELOG.md if it doesn't exist
          if [[ ! -f v3/CHANGELOG.md ]]; then
            echo "$changelog_header" > v3/CHANGELOG.md
            echo "" >> v3/CHANGELOG.md
          fi

          # Check if this version already exists
          if grep -q "## \[$version\]" v3/CHANGELOG.md; then
            echo "Version $version already exists in v3/CHANGELOG.md, skipping update"
            exit 0
          fi

          # Read existing content after header
          if grep -q "<!-- Entries below are auto-generated" v3/CHANGELOG.md; then
            existing_content=$(sed -n '/<!-- Entries below are auto-generated/,$ p' v3/CHANGELOG.md | tail -n +2)
          else
            existing_content=$(cat v3/CHANGELOG.md 2>/dev/null || echo "")
          fi

          # Rebuild CHANGELOG.md with new version at top
          {
            echo "$changelog_header"
            echo ""
            cat changelog.md
            echo ""
            echo "$existing_content"
          } > v3/CHANGELOG.md.new

          mv v3/CHANGELOG.md.new v3/CHANGELOG.md

      - name: Bump v3/Cargo.toml to NEXT version for development
        id: bump-version
        run: |
          released_version="${{ needs.validate-tag.outputs.version }}"

          # Calculate the NEXT version by incrementing the last number in the prerelease
          # Examples:
          #   3.0.0-alpha.6 -> 3.0.0-alpha.7
          #   3.0.0-beta.2  -> 3.0.0-beta.3
          #   3.0.0         -> 3.0.1 (stable: bump patch)

          if [[ "$released_version" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-([a-zA-Z]+)\.([0-9]+)$ ]]; then
            # Prerelease version: bump the prerelease number
            base="${BASH_REMATCH[1]}"
            prerelease_type="${BASH_REMATCH[2]}"
            prerelease_num="${BASH_REMATCH[3]}"
            next_num=$((prerelease_num + 1))
            next_version="${base}-${prerelease_type}.${next_num}"
          elif [[ "$released_version" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            # Stable version: bump patch number
            major="${BASH_REMATCH[1]}"
            minor="${BASH_REMATCH[2]}"
            patch="${BASH_REMATCH[3]}"
            next_patch=$((patch + 1))
            next_version="${major}.${minor}.${next_patch}"
          else
            echo "::error::Cannot parse version format: $released_version"
            exit 1
          fi

          echo "Released version: $released_version"
          echo "Next dev version: $next_version"
          echo "next_version=$next_version" >> "$GITHUB_OUTPUT"

          # Update workspace version in v3/Cargo.toml
          sed -i 's/^version = ".*"$/version = "'"$next_version"'"/' v3/Cargo.toml

          echo "Updated v3/Cargo.toml to version $next_version for next development cycle"

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Regenerate Cargo.lock
        run: |
          cd v3
          cargo generate-lockfile
          echo "Regenerated v3/Cargo.lock"

      - name: Commit version updates
        run: |
          released_version="${{ needs.validate-tag.outputs.version }}"
          next_version="${{ steps.bump-version.outputs.next_version }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes to commit
          if git diff --quiet v3/CHANGELOG.md v3/Cargo.toml v3/Cargo.lock; then
            echo "No changes to commit"
            exit 0
          fi

          git add v3/CHANGELOG.md v3/Cargo.toml v3/Cargo.lock
          git commit -m "chore(release): update v3 CHANGELOG and bump to v$next_version for development

          Released: v$released_version
          Next development version: v$next_version

          [skip ci]"
          git push origin main

  # Job 9: Create GitHub Release
  create-release:
    runs-on: ubuntu-latest
    needs: [validate-tag, generate-changelog, build-binaries, promote-image, sign-image, attest-provenance, generate-sbom]
    permissions:
      contents: write
    outputs:
      release_url: ${{ steps.release.outputs.url }}
    steps:
      - uses: actions/checkout@v6

      - name: Download all binary artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts

      - name: Download changelog
        uses: actions/download-artifact@v7
        with:
          name: changelog-v3

      - name: Download SBOM
        uses: actions/download-artifact@v7
        with:
          name: sbom-v${{ needs.validate-tag.outputs.version }}

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          find artifacts -name "sindri-*.tar.gz" -exec cp {} release-assets/ \;
          find artifacts -name "sindri-*.zip" -exec cp {} release-assets/ \;

          # Copy SBOM to release assets
          cp sbom.spdx.json release-assets/

          ls -lh release-assets/

      - name: Generate checksums
        run: |
          cd release-assets
          echo "Generating SHA256 checksums..."

          # Generate checksums for all binaries
          sha256sum sindri-*.tar.gz sindri-*.zip 2>/dev/null > checksums.txt || true

          # Also generate individual .sha256 files for each asset
          for file in sindri-*.tar.gz sindri-*.zip; do
            if [[ -f "$file" ]]; then
              sha256sum "$file" > "${file}.sha256"
              echo "  ‚úì $file"
            fi
          done

          echo ""
          echo "Checksums:"
          cat checksums.txt

      - name: Create install.sh script
        run: |
          version="${{ needs.validate-tag.outputs.version }}"
          cat > release-assets/install-v3.sh << 'INSTALL_EOF'
          #!/usr/bin/env bash
          # Sindri v3 Installation Script
          # Generated for version: VERSION_PLACEHOLDER
          set -euo pipefail

          VERSION="VERSION_PLACEHOLDER"
          REPO="REPO_PLACEHOLDER"

          echo "Installing Sindri v3 $VERSION..."

          # Detect OS and architecture
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)

          case "$OS" in
            linux)
              case "$ARCH" in
                x86_64) PLATFORM="linux-x86_64" ;;
                aarch64|arm64) PLATFORM="linux-aarch64" ;;
                *) echo "Unsupported architecture: $ARCH"; exit 1 ;;
              esac
              EXT="tar.gz"
              ;;
            darwin)
              PLATFORM="macos-aarch64"
              EXT="tar.gz"
              ;;
            mingw*|msys*|cygwin*)
              PLATFORM="windows-x86_64"
              EXT="zip"
              ;;
            *)
              echo "Unsupported OS: $OS"
              exit 1
              ;;
          esac

          FILENAME="sindri-v${VERSION}-${PLATFORM}.${EXT}"
          URL="https://github.com/${REPO}/releases/download/v${VERSION}/${FILENAME}"

          echo "Downloading $FILENAME..."
          curl -L -o "$FILENAME" "$URL"

          echo "Extracting..."
          if [[ "$EXT" == "tar.gz" ]]; then
            tar -xzf "$FILENAME"
          else
            unzip "$FILENAME"
          fi

          echo "Installing to /usr/local/bin..."
          sudo mv sindri /usr/local/bin/ || mv sindri /usr/local/bin/

          echo ""
          echo "Sindri v3 $VERSION installed successfully!"
          echo "Run 'sindri --version' to verify installation."
          INSTALL_EOF

          sed -i "s/VERSION_PLACEHOLDER/$version/g" release-assets/install-v3.sh
          sed -i "s|REPO_PLACEHOLDER|${{ github.repository }}|g" release-assets/install-v3.sh
          chmod +x release-assets/install-v3.sh

      - name: Create verification guide
        run: |
          version="${{ needs.validate-tag.outputs.version }}"
          cat > release-assets/VERIFY.md << 'VERIFY_EOF'
          # Verification Guide for Sindri v3 VERSION_PLACEHOLDER

          This release includes cryptographic signatures and Software Bill of Materials (SBOM) for supply chain security.

          ## Docker Image Verification

          ### Verify Signature (Cosign 3.x)

          ```bash
          # Install cosign 3.x (if not already installed)
          # https://docs.sigstore.dev/cosign/installation/

          # Verify image signature
          cosign verify ghcr.io/REPO_PLACEHOLDER:VERSION_PLACEHOLDER \
            --certificate-identity-regexp='https://github.com/REPO_PLACEHOLDER' \
            --certificate-oidc-issuer='https://token.actions.githubusercontent.com'
          ```

          ### Verify Build Provenance (SLSA)

          ```bash
          # Verify SLSA provenance attestation
          cosign verify-attestation \
            --type slsaprovenance \
            --certificate-identity-regexp='https://github.com/REPO_PLACEHOLDER' \
            --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
            ghcr.io/REPO_PLACEHOLDER:VERSION_PLACEHOLDER

          # Or use the sindri CLI
          sindri image verify ghcr.io/REPO_PLACEHOLDER:VERSION_PLACEHOLDER
          ```

          ### Download SBOM

          ```bash
          # Download SBOM attestation
          cosign download sbom ghcr.io/REPO_PLACEHOLDER:VERSION_PLACEHOLDER > sbom.spdx.json

          # Or download from GitHub Release assets (attached)
          ```

          ### Inspect SBOM

          ```bash
          # View SBOM summary
          jq '.packages[] | {name, version, supplier}' sbom.spdx.json | head -20
          ```

          ## Binary Verification

          ### Checksums

          Download and verify release binaries using the checksums file:

          ```bash
          # Download checksums file
          curl -LO https://github.com/REPO_PLACEHOLDER/releases/download/vVERSION_PLACEHOLDER/checksums.txt

          # Download your platform binary
          curl -LO https://github.com/REPO_PLACEHOLDER/releases/download/vVERSION_PLACEHOLDER/sindri-vVERSION_PLACEHOLDER-linux-x86_64.tar.gz

          # Verify checksum
          sha256sum -c checksums.txt --ignore-missing

          # Or verify individual file
          sha256sum sindri-vVERSION_PLACEHOLDER-*.tar.gz
          ```

          ## Security Scanning

          This image has been scanned with Trivy during CI:
          - **Critical/High Vulnerabilities**: See GitHub Security tab
          - **SARIF Report**: Uploaded to GitHub Code Scanning

          ## Build Provenance

          - **Signing**: Cosign 3.x keyless (signed by digest)
          - **SLSA Provenance**: Attested via `actions/attest-build-provenance`
          - **CI Image**: Promoted from tested CI build (v3-ci-passed-SHA)
          - **Build Workflow**: https://github.com/REPO_PLACEHOLDER/actions
          - **Commit SHA**: Check image labels or SBOM metadata
          - **Multi-arch**: linux/amd64, linux/arm64
          VERIFY_EOF

          # Replace placeholders
          sed -i "s/VERSION_PLACEHOLDER/$version/g" release-assets/VERIFY.md
          sed -i "s|REPO_PLACEHOLDER|${{ github.repository }}|g" release-assets/VERIFY.md

      - name: Create GitHub Release
        id: release
        uses: softprops/action-gh-release@v2
        with:
          name: Sindri v${{ needs.validate-tag.outputs.version }} (Rust)
          body_path: changelog.md
          prerelease: ${{ needs.validate-tag.outputs.is_prerelease }}
          files: |
            release-assets/*

  # Job 10: Notify on success or failure
  notify-release:
    runs-on: ubuntu-latest
    needs: [validate-tag, create-release, update-version-files, promote-image, sign-image, attest-provenance, generate-sbom]
    if: always()
    permissions:
      contents: read
      issues: write
    steps:
      - uses: actions/checkout@v6

      - name: Notify success
        if: needs.create-release.result == 'success'
        run: |
          version="${{ needs.validate-tag.outputs.version }}"
          echo "::notice::Release v$version (v3 Rust) published successfully!"
          echo ""
          echo "üì¶ Release Details:"
          echo "   URL:    ${{ needs.create-release.outputs.release_url }}"
          echo "   Image:  ghcr.io/${{ github.repository }}:$version"
          echo ""
          echo "üîê Security Features:"
          echo "   ‚úÖ Image signed with Cosign 3.x (keyless, by digest)"
          echo "   ‚úÖ SLSA build provenance attested"
          echo "   ‚úÖ SBOM generated (SPDX format)"
          echo "   ‚úÖ SHA256 checksums for all binaries"
          echo "   ‚úÖ Vulnerability scan completed"
          echo "   ‚úÖ Promoted from tested CI build"
          echo "   ‚úÖ Multi-arch support (amd64, arm64)"
          echo ""
          echo "Verify with:"
          echo "   cosign verify ghcr.io/${{ github.repository }}:$version \\"
          echo "     --certificate-identity-regexp='https://github.com/${{ github.repository }}' \\"
          echo "     --certificate-oidc-issuer='https://token.actions.githubusercontent.com'"

      - name: Create failure issue
        if: failure()
        uses: actions/github-script@v8
        with:
          script: |
            const version = '${{ needs.validate-tag.outputs.version }}';
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Release v${version} (v3 Rust) failed`,
              body: `## Release Failure

            The automated release for **v${version}** (v3 Rust binaries) failed.

            ### Details

            - **Tag**: v${version}
            - **Workflow Run**: ${runUrl}
            - **Triggered by**: @${context.actor}

            ### Next Steps

            1. Review the [workflow logs](${runUrl})
            2. Fix any issues
            3. Delete the tag and recreate it, or create a new patch version

            \`\`\`bash
            # To retry with same version:
            git tag -d v${version}
            git push origin :refs/tags/v${version}
            # Fix issues...
            git tag v${version}
            git push origin v${version}
            \`\`\`
            `,
              labels: ['release-failure', 'automated', 'v3']
            });
