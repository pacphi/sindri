#!/bin/bash
#
# new-project - Create new project from template
#
# Creates a new project directory with intelligent type detection, template-based
# structure, extension activation via extension-manager, and Claude AI enhancements.
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Determine lib directory (support both container and local paths)
if [[ -d "/docker/lib" ]]; then
    DOCKER_LIB="/docker/lib"
else
    DOCKER_LIB="$(cd "${SCRIPT_DIR}/../docker/lib" && pwd)"
fi
export DOCKER_LIB

source "${DOCKER_LIB}/common.sh"
source "${DOCKER_LIB}/git.sh"
source "${DOCKER_LIB}/project-core.sh"
source "${DOCKER_LIB}/project-templates.sh"

TEMPLATES_CONFIG="${DOCKER_LIB}/project-templates.yaml"
PROJECT_NAME=""
PROJECT_TYPE=""
AUTO_DETECT=true
GIT_NAME=""
GIT_EMAIL=""
SKIP_TOOLS=false
INTERACTIVE=false

show_usage() {
    echo "Usage: $0 <project_name> [options]"
    echo ""
    echo "Options:"
    echo "  --type <type>              Specify project type explicitly"
    echo "  --list-types               Show all available project types"
    echo "  --interactive              Force interactive type selection"
    echo "  --git-name <name>          Git user name for this project"
    echo "  --git-email <email>        Git user email for this project"
    echo "  --skip-tools               Skip agentic tool initialization (claude-flow, aqe, etc.)"
    echo "  -h, --help                 Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 my-rails-app            # Auto-detects Rails"
    echo "  $0 api-server              # Prompts for API type"
    echo "  $0 my-app --type python"
    echo "  $0 my-app --type spring --git-name \"John Doe\""

    if [[ -f "$TEMPLATES_CONFIG" ]]; then
        echo ""
        echo "Available Types:"
        get_template_types | pr -t -4
    fi
    exit 1
}

list_types() {
    echo "Available Project Types:"
    echo ""

    if [[ -f "$TEMPLATES_CONFIG" ]]; then
        while IFS= read -r type; do
            local desc
            desc=$(get_template_description "$type")
            printf "  %-12s %s\n" "$type" "$desc"
        done < <(get_template_types)
    fi
    exit 0
}

# Select project type interactively when detection is ambiguous or no match
# Uses YAML-driven detection from project-templates.sh
select_project_type() {
    local detected="$1"

    # Handle ambiguous detection (e.g., "ambiguous:node,go,python")
    if [[ "$detected" == ambiguous:* ]]; then
        local suggestions="${detected#ambiguous:}"

        print_status "Multiple project types match. Which do you prefer?" >&2
        echo "Suggested types:" >&2
        get_type_suggestions "$suggestions" >&2
        echo "" >&2

        local count
        count=$(echo "$suggestions" | tr ',' '\n' | wc -l | tr -d ' ')

        # Clear stdin to avoid buffer pollution
        while read -r -t 0; do read -r; done 2>/dev/null

        local choice
        read -r -p "Enter choice (1-${count}) or type name: " choice </dev/tty

        # Strip ANSI escape codes and whitespace
        choice=$(echo "$choice" | sed 's/\x1b\[[0-9;]*m//g' | tr -d '[:space:]' | tr -d '[:cntrl:]')

        local resolved
        resolved=$(resolve_type_choice "$choice" "$suggestions")
        echo "$resolved"
    else
        # No detection - show all available types
        print_status "Available project types:" >&2
        get_template_types | pr -t -3 >&2
        echo "" >&2

        # Clear stdin to avoid buffer pollution
        while read -r -t 0; do read -r; done 2>/dev/null

        local input
        read -r -p "Enter project type [default: node]: " input </dev/tty

        # Strip ANSI escape codes and whitespace
        input=$(echo "$input" | sed 's/\x1b\[[0-9;]*m//g' | tr -d '[:space:]' | tr -d '[:cntrl:]')

        echo "${input:-node}"
    fi
}

collect_template_variables() {
    local project_name="$1"

    local vars_json="{}"
    vars_json=$(echo "$vars_json" | yq eval ".project_name = \"$project_name\"" -)
    vars_json=$(echo "$vars_json" | yq eval ".author = \"$(git config user.name 2>/dev/null || echo '')\"" -)
    vars_json=$(echo "$vars_json" | yq eval ".git_user_name = \"$(git config user.name 2>/dev/null || echo '')\"" -)
    vars_json=$(echo "$vars_json" | yq eval ".git_user_email = \"$(git config user.email 2>/dev/null || echo '')\"" -)
    vars_json=$(echo "$vars_json" | yq eval ".date = \"$(date +%Y-%m-%d)\"" -)
    vars_json=$(echo "$vars_json" | yq eval ".year = \"$(date +%Y)\"" -)
    vars_json=$(echo "$vars_json" | yq eval ".description = \"Project description\"" -)
    vars_json=$(echo "$vars_json" | yq eval ".license = \"MIT\"" -)

    echo "$vars_json"
}

activate_extensions() {
    local template_json="$1"

    print_status "Activating extensions..."

    local extensions
    extensions=$(echo "$template_json" | yq eval '.extensions // [] | .[]' -)

    if [[ -z "$extensions" ]]; then
        print_debug "No extensions to activate"
        return 0
    fi

    while IFS= read -r ext; do
        if [[ -n "$ext" ]]; then
            print_status "Activating extension: $ext"
            if command_exists extension-manager; then
                if "${SCRIPT_DIR}/extension-manager" install "$ext" 2>/dev/null; then
                    print_success "Extension activated: $ext"
                else
                    print_warning "Failed to activate extension: $ext"
                fi
            else
                print_warning "extension-manager not available, skipping: $ext"
            fi
        fi
    done <<< "$extensions"

    return 0
}

if [ $# -eq 0 ]; then
    show_usage
fi

case "${1:-}" in
    --list-types)
        list_types
        ;;
    -h|--help)
        show_usage
        ;;
esac

PROJECT_NAME="$1"
shift

while [[ $# -gt 0 ]]; do
    case $1 in
        --type)
            PROJECT_TYPE="$2"
            AUTO_DETECT=false
            shift 2
            ;;
        --interactive)
            INTERACTIVE=true
            shift
            ;;
        --list-types)
            list_types
            ;;
        --git-name)
            GIT_NAME="$2"
            shift 2
            ;;
        --git-email)
            GIT_EMAIL="$2"
            shift 2
            ;;
        --skip-tools)
            SKIP_TOOLS=true
            shift
            ;;
        -h|--help)
            show_usage
            ;;
        *)
            print_error "Unknown option: $1"
            show_usage
            ;;
    esac
done

if [[ "$AUTO_DETECT" == "true" ]] && [[ -z "$PROJECT_TYPE" ]]; then
    # Use YAML-driven detection from project-templates.sh
    DETECTED_TYPE=$(detect_type_from_name "$PROJECT_NAME")

    if [[ -n "$DETECTED_TYPE" ]] && [[ "$DETECTED_TYPE" != ambiguous:* ]] && [[ "$INTERACTIVE" != "true" ]]; then
        # Unambiguous match - use it directly
        PROJECT_TYPE="$DETECTED_TYPE"
        print_status "Auto-detected project type: $PROJECT_TYPE"
    else
        # Ambiguous or no match - prompt user
        PROJECT_TYPE=$(select_project_type "$DETECTED_TYPE")
    fi
fi

if [[ -z "$PROJECT_TYPE" ]]; then
    PROJECT_TYPE="node"
fi

# Resolve aliases (e.g., "nodejs" -> "node", "py" -> "python")
PROJECT_TYPE=$(resolve_template_alias "$PROJECT_TYPE")

if [[ -f "$TEMPLATES_CONFIG" ]]; then
    if ! get_template_types | grep -q "^${PROJECT_TYPE}$"; then
        print_warning "Unknown project type: $PROJECT_TYPE"
        print_status "Available types: $(get_template_types | tr '\n' ' ')"
        PROJECT_TYPE=$(select_project_type "")
    fi
fi

# Use WORKSPACE_PROJECTS if available, otherwise use local projects dir
PROJECTS_BASE="${WORKSPACE_PROJECTS:-${HOME}/projects}"
PROJECT_DIR="$PROJECTS_BASE/$PROJECT_NAME"

if [ -d "$PROJECT_DIR" ]; then
    print_error "Project $PROJECT_NAME already exists"
    exit 1
fi

print_status "Creating new $PROJECT_TYPE project: $PROJECT_NAME"

print_status "Loading template: $PROJECT_TYPE"
template_json=$(load_project_template "$PROJECT_TYPE") || exit 1

activate_extensions "$template_json"

mkdir -p "$PROJECT_DIR" || exit 1
cd "$PROJECT_DIR" || exit 1

init_git_repo "$PROJECT_DIR" "$PROJECT_TYPE" || exit 1

if [[ -n "$GIT_NAME" ]] || [[ -n "$GIT_EMAIL" ]]; then
    apply_git_config_overrides ${GIT_NAME:+--name "$GIT_NAME"} ${GIT_EMAIL:+--email "$GIT_EMAIL"} || exit 1
fi

variables_json=$(collect_template_variables "$PROJECT_NAME")
execute_template_setup "$template_json" "$variables_json" || exit 1
create_template_files "$template_json" "$variables_json" || exit 1

claude_template=$(echo "$template_json" | yq eval '.claude_md_template // ""' -)
if [[ -n "$claude_template" ]]; then
    claude_template=$(resolve_template_variables "$claude_template" "$variables_json")
    create_project_claude_md --template "$claude_template" || exit 1
else
    create_project_claude_md || exit 1
fi

git add .
git commit -m "feat: initial project setup for $PROJECT_NAME"

setup_project_enhancements \
    $([[ "$SKIP_TOOLS" == "true" ]] && echo "--skip-tools") \
    ${GIT_NAME:+--git-name "$GIT_NAME"} \
    ${GIT_EMAIL:+--git-email "$GIT_EMAIL"} || exit 1

print_success "Project $PROJECT_NAME created successfully"
echo "üìÅ Location: $PROJECT_DIR"
echo "üìù Next steps:"
echo "   1. cd $PROJECT_DIR"
echo "   2. Edit CLAUDE.md with project details"
echo "   3. Start coding with: claude"

echo ""
echo "Initialized Tools:"
(
    cd "$PROJECT_DIR" || exit 1

    # Non-extension tools (keep as-is)
    if command_exists claude; then echo "  ‚úì Claude Code"; fi
    if command_exists uvx && [[ -f ".github/spec.json" ]]; then echo "  ‚úì GitHub spec-kit"; fi

    # Extension-based tools (dynamic capability reporting)
    if [[ -f "${SCRIPT_DIR}/../docker/lib/capability-manager.sh" ]]; then
        source "${SCRIPT_DIR}/../docker/lib/capability-manager.sh"
        report_initialized_extensions
    fi
)

echo ""
echo "Git Configuration:"
echo "   User: $(git config user.name) <$(git config user.email)>"
echo "   Branch: $(git branch --show-current)"
