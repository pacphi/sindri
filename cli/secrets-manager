#!/bin/bash
# Secrets Manager - Centralized secret resolution for all providers
#
# This module provides secret resolution from multiple sources:
# - env: Environment variables and .env files
# - file: Files (certificates, keys, configs)
# - vault: HashiCorp Vault KV store
#
# Public API:
#   secrets_resolve_all      - Resolve all secrets from sindri.yaml
#   secrets_validate         - Validate all secrets are available
#   secrets_generate_env     - Generate .env file for provider
#   secrets_inject_fly       - Inject secrets into Fly.io
#   secrets_inject_docker    - Generate docker-compose secrets config
#   secrets_inject_k8s       - Generate Kubernetes Secret YAML
#   secrets_inject_devpod    - Generate devcontainer.json env config

set -euo pipefail

# Get script directory
SECRETS_MANAGER_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source common utilities
# shellcheck source=../docker/lib/common.sh
source "${SECRETS_MANAGER_DIR}/../docker/lib/common.sh"

# Temporary files for secret storage (in memory if possible)
# H-2 Security Fix: Use tmpfs for in-memory storage and restrictive permissions
if [[ -d "/dev/shm" ]] && mountpoint -q /dev/shm 2>/dev/null; then
    # Prefer tmpfs (in-memory) for sensitive data
    SECRET_TMPDIR="/dev/shm"
else
    # Fall back to regular tmp with restrictive permissions
    SECRET_TMPDIR="${TMPDIR:-/tmp}"
fi

# Set restrictive umask for secret files (owner-only access)
ORIGINAL_UMASK=$(umask)
umask 077

SECRETS_CACHE="${SECRET_TMPDIR}/sindri-secrets-$$"
FILE_SECRETS_CACHE="${SECRET_TMPDIR}/sindri-file-secrets-$$"
VALIDATION_ERRORS=0

# Restore original umask
umask "$ORIGINAL_UMASK"

# Cleanup on exit
cleanup_secrets() {
    # Securely remove secret caches
    if [[ -f "$SECRETS_CACHE" ]]; then
        # Overwrite before deletion for extra security
        dd if=/dev/zero of="$SECRETS_CACHE" bs=1k count=$(du -k "$SECRETS_CACHE" 2>/dev/null | cut -f1) 2>/dev/null || true
        rm -f "$SECRETS_CACHE"
    fi
    if [[ -f "$FILE_SECRETS_CACHE" ]]; then
        dd if=/dev/zero of="$FILE_SECRETS_CACHE" bs=1k count=$(du -k "$FILE_SECRETS_CACHE" 2>/dev/null | cut -f1) 2>/dev/null || true
        rm -f "$FILE_SECRETS_CACHE"
    fi
}
trap cleanup_secrets EXIT

#######################################
# Validate and renew Vault token (H-8 security fix)
# Ensures token is valid and attempts renewal if needed
# Returns:
#   0 if token is valid or renewed successfully, 1 otherwise
#######################################
vault_token_validate_and_renew() {
    # Skip if vault command not available
    if ! command -v vault &>/dev/null; then
        return 0
    fi

    # Check if token is valid
    if ! vault token lookup &>/dev/null; then
        print_error "Vault token is invalid or expired"
        print_status "  For automatic token management, consider using Vault Agent:"
        print_status "  https://developer.hashicorp.com/vault/docs/agent"
        print_status ""
        print_status "  Or manually renew: vault token renew"
        return 1
    fi

    # Get token information
    local token_info
    token_info=$(vault token lookup -format=json 2>/dev/null)

    if [[ -z "$token_info" ]]; then
        print_warning "Could not retrieve token information"
        return 0
    fi

    # Check if token is renewable
    local renewable
    renewable=$(echo "$token_info" | jq -r '.data.renewable' 2>/dev/null || echo "false")

    if [[ "$renewable" == "true" ]]; then
        # Get TTL (time to live) in seconds
        local ttl
        ttl=$(echo "$token_info" | jq -r '.data.ttl' 2>/dev/null || echo "0")

        # Renew if TTL is less than 1 hour (3600 seconds)
        if [[ "$ttl" -lt 3600 ]]; then
            print_status "  Renewing Vault token (TTL: ${ttl}s)..."
            if vault token renew &>/dev/null; then
                print_success "  ✓ Token renewed successfully"
            else
                print_warning "  ⚠ Token renewal failed (may be at max TTL)"
            fi
        fi
    fi

    return 0
}

#######################################
# Resolve all secrets from sindri.yaml
# Arguments:
#   $1 - Path to sindri.yaml (default: sindri.yaml)
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_resolve_all() {
    local config="${1:-sindri.yaml}"

    if [[ ! -f "$config" ]]; then
        print_error "Configuration file not found: $config"
        return 1
    fi

    # Initialize cache files
    : > "$SECRETS_CACHE"
    : > "$FILE_SECRETS_CACHE"

    # Check if secrets are defined
    local secrets_count
    secrets_count=$(yq '.secrets | length' "$config" 2>/dev/null || echo "0")

    if [[ "$secrets_count" == "0" ]] || [[ "$secrets_count" == "null" ]]; then
        print_status "No secrets configured in $config"
        return 0
    fi

    print_status "Resolving $secrets_count secret(s)..."

    # Process each secret
    local i
    for ((i=0; i<secrets_count; i++)); do
        local secret_json
        secret_json=$(yq ".secrets[$i]" -o=json "$config")

        local name source
        name=$(echo "$secret_json" | jq -r '.name')
        source=$(echo "$secret_json" | jq -r '.source')

        case "$source" in
            env)
                _resolve_env_secret "$secret_json" "$config"
                ;;
            file)
                _resolve_file_secret "$secret_json" "$config"
                ;;
            vault)
                _resolve_vault_secret "$secret_json" "$config"
                ;;
            *)
                print_error "Unknown secret source '$source' for $name"
                return 1
                ;;
        esac
    done

    if [[ $VALIDATION_ERRORS -gt 0 ]]; then
        print_error "Failed to resolve $VALIDATION_ERRORS secret(s)"
        return 1
    fi

    print_success "All secrets resolved successfully"
    return 0
}

#######################################
# Resolve environment variable secret
# Arguments:
#   $1 - Secret JSON object
#   $2 - Path to sindri.yaml
# Returns:
#   0 on success, 1 on failure
#######################################
_resolve_env_secret() {
    local secret="$1"
    local config="$2"
    local name value required from_file

    name=$(echo "$secret" | jq -r '.name')
    required=$(echo "$secret" | jq -r '.required // false')
    from_file=$(echo "$secret" | jq -r '.fromFile // ""')

    # Priority: shell env > .env.local > .env > fromFile
    if [[ -n "${!name:-}" ]]; then
        value="${!name}"
        print_status "  ✓ $name (from shell environment)"
    elif [[ -f .env.local ]] && grep -q "^${name}=" .env.local 2>/dev/null; then
        value=$(grep "^${name}=" .env.local | head -1 | cut -d= -f2-)
        # Remove quotes if present
        value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
        print_status "  ✓ $name (from .env.local)"
    elif [[ -f .env ]] && grep -q "^${name}=" .env 2>/dev/null; then
        value=$(grep "^${name}=" .env | head -1 | cut -d= -f2-)
        # Remove quotes if present
        value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
        print_status "  ✓ $name (from .env)"
    elif [[ -n "$from_file" ]]; then
        # fromFile: read content from file path (supports ~ expansion)
        local file_path="${from_file/#\~/$HOME}"
        if [[ -f "$file_path" ]]; then
            value=$(cat "$file_path")
            print_status "  ✓ $name (from file: $from_file)"
        fi
    fi

    if [[ -z "${value:-}" ]]; then
        if [[ "$required" == "true" ]]; then
            print_error "  ✗ Required secret $name not found"
            if [[ -n "$from_file" ]]; then
                print_status "    Checked: \$$name, .env.local, .env, $from_file"
            else
                print_status "    Checked: \$$name, .env.local, .env"
            fi
            print_status "    Hint: export $name=<value> or add to .env.local"
            ((VALIDATION_ERRORS++)) || true
            return 1
        else
            if [[ -n "$from_file" ]]; then
                print_warning "  ⚠ Optional secret $name not found (checked $from_file)"
            else
                print_warning "  ⚠ Optional secret $name not found (will not be set)"
            fi
            return 0
        fi
    fi

    # Output to resolved secrets cache
    echo "${name}=${value}" >> "$SECRETS_CACHE"
    return 0
}

#######################################
# Resolve file secret
# Arguments:
#   $1 - Secret JSON object
#   $2 - Path to sindri.yaml
# Returns:
#   0 on success, 1 on failure
#######################################
_resolve_file_secret() {
    local secret="$1"
    local config="$2"
    local name path mount_path permissions required

    name=$(echo "$secret" | jq -r '.name')
    path=$(echo "$secret" | jq -r '.path')
    mount_path=$(echo "$secret" | jq -r '.mountPath // ""')
    permissions=$(echo "$secret" | jq -r '.permissions // "0644"')
    required=$(echo "$secret" | jq -r '.required // false')

    # Expand ~ and relative paths
    path="${path/#\~/$HOME}"
    if [[ ! "$path" =~ ^/ ]]; then
        # Relative path - make absolute relative to config directory
        local config_dir
        config_dir="$(cd "$(dirname "$config")" && pwd)"
        path="${config_dir}/${path}"
    fi

    # Security: Validate path to prevent directory traversal (M-3)
    # Reference: https://wiki.sei.cmu.edu/confluence/x/DtcxBQ
    # Check for directory traversal patterns
    if [[ "$path" =~ \.\. ]]; then
        print_error "  ✗ Invalid secret path contains directory traversal: $path"
        ((VALIDATION_ERRORS++)) || true
        return 1
    fi

    # Canonicalize path using realpath if file exists
    # For non-existent files, we'll validate the parent directory
    local canonical_path
    if [[ -e "$path" ]]; then
        canonical_path=$(realpath "$path" 2>/dev/null)
    else
        # For non-existent files, canonicalize the parent directory
        local parent_dir
        parent_dir=$(dirname "$path")
        if [[ -d "$parent_dir" ]]; then
            canonical_path=$(realpath "$parent_dir" 2>/dev/null)/$(basename "$path")
        else
            canonical_path="$path"
        fi
    fi

    # Validate resolved path stays within allowed directories
    local allowed_dirs=("$HOME" "/etc/ssl/certs" "/tmp" "/var/tmp")
    local path_allowed=false
    for allowed in "${allowed_dirs[@]}"; do
        # Canonicalize allowed directory for comparison
        local canonical_allowed
        canonical_allowed=$(realpath -m "$allowed" 2>/dev/null || echo "$allowed")
        if [[ "$canonical_path" == "$canonical_allowed"* ]]; then
            path_allowed=true
            break
        fi
    done

    if [[ "$path_allowed" != "true" ]]; then
        print_error "  ✗ Secret path outside allowed directories: $canonical_path"
        print_error "     Allowed directories: ${allowed_dirs[*]}"
        ((VALIDATION_ERRORS++)) || true
        return 1
    fi

    # Update path to use canonical path
    path="$canonical_path"

    if [[ ! -f "$path" ]]; then
        if [[ "$required" == "true" ]]; then
            print_error "  ✗ Secret file not found: $path"
            ((VALIDATION_ERRORS++)) || true
            return 1
        else
            print_warning "  ⚠ Optional secret file not found: $path (will not be set)"
            return 0
        fi
    fi

    # Get file size for display
    local size
    if [[ "$OSTYPE" == "darwin"* ]]; then
        size=$(stat -f%z "$path")
    else
        size=$(stat -c%s "$path")
    fi

    # Base64 encode for safe transport
    local content_b64
    content_b64=$(base64 < "$path" | tr -d '\n')

    print_status "  ✓ $name (file: $path, ${size} bytes)"

    # Store metadata: name|file|path|mount_path|permissions|base64_content
    echo "${name}|file|${path}|${mount_path}|${permissions}|${content_b64}" >> "$FILE_SECRETS_CACHE"
    return 0
}

#######################################
# Resolve Vault secret
# Arguments:
#   $1 - Secret JSON object
#   $2 - Path to sindri.yaml
# Returns:
#   0 on success, 1 on failure
#######################################
_resolve_vault_secret() {
    local secret="$1"
    local config="$2"
    local name vault_path vault_key vault_mount value required

    name=$(echo "$secret" | jq -r '.name')
    vault_path=$(echo "$secret" | jq -r '.vaultPath')
    vault_key=$(echo "$secret" | jq -r '.vaultKey')
    vault_mount=$(echo "$secret" | jq -r '.vaultMount // "secret"')
    required=$(echo "$secret" | jq -r '.required // false')

    # Check Vault CLI availability
    if ! command -v vault &> /dev/null; then
        print_error "  ✗ vault CLI not found (required for $name)"
        print_status "    Install: https://www.vaultproject.io/downloads"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++)) || true
            return 1
        fi
        return 0
    fi

    # Check authentication
    if [[ -z "${VAULT_ADDR:-}" ]]; then
        print_error "  ✗ VAULT_ADDR not set (required for $name)"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++)) || true
            return 1
        fi
        return 0
    fi

    if [[ -z "${VAULT_TOKEN:-}" ]] && [[ ! -f ~/.vault-token ]]; then
        print_error "  ✗ VAULT_TOKEN not set and ~/.vault-token not found"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++)) || true
            return 1
        fi
        return 0
    fi

    # H-8 Security Fix: Validate and renew Vault token
    if ! vault_token_validate_and_renew; then
        print_error "  ✗ Vault token validation/renewal failed"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++)) || true
            return 1
        fi
        return 0
    fi

    # Retrieve secret
    value=$(vault kv get -mount="$vault_mount" -field="$vault_key" "$vault_path" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$value" ]]; then
        print_error "  ✗ Failed to retrieve $name from Vault"
        print_status "    Path: $vault_mount/$vault_path"
        print_status "    Key: $vault_key"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++)) || true
            return 1
        fi
        return 0
    fi

    print_status "  ✓ $name (from vault:$vault_mount/$vault_path)"
    echo "${name}=${value}" >> "$SECRETS_CACHE"
    return 0
}

#######################################
# Validate all secrets without resolving
# Arguments:
#   $1 - Path to sindri.yaml (default: sindri.yaml)
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_validate() {
    local config="${1:-sindri.yaml}"

    print_header "Validating secrets from $config"

    VALIDATION_ERRORS=0
    secrets_resolve_all "$config"

    if [[ $VALIDATION_ERRORS -eq 0 ]]; then
        print_success "All secrets validated successfully"
        return 0
    else
        print_error "Validation failed: $VALIDATION_ERRORS error(s)"
        return 1
    fi
}

#######################################
# Generate .env file from resolved secrets
# Arguments:
#   $1 - Output file path (default: .env.secrets)
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_generate_env() {
    local output="${1:-.env.secrets}"

    if [[ ! -f "$SECRETS_CACHE" ]]; then
        print_error "No secrets resolved. Run secrets_resolve_all first."
        return 1
    fi

    cp "$SECRETS_CACHE" "$output"
    chmod 600 "$output"

    print_success "Generated environment file: $output"
    return 0
}

#######################################
# Inject secrets into Fly.io app
# Arguments:
#   $1 - Fly.io app name
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_inject_fly() {
    local app_name="$1"

    if [[ ! -f "$SECRETS_CACHE" ]] || [[ ! -s "$SECRETS_CACHE" ]]; then
        print_status "No environment secrets to inject"
    else
        print_status "Injecting secrets into Fly.io app: $app_name"

        # Use flyctl secrets import for atomic update
        flyctl secrets import -a "$app_name" < "$SECRETS_CACHE"
    fi

    # Handle file secrets
    if [[ -f "$FILE_SECRETS_CACHE" ]] && [[ -s "$FILE_SECRETS_CACHE" ]]; then
        print_status "Injecting file secrets (base64 encoded)..."

        while IFS='|' read -r name type path mount_path permissions content_b64; do
            # Use stdin to prevent secrets exposure in process arguments (C-4 security fix)
            {
                echo "${name}_BASE64=${content_b64}"
                echo "${name}_MOUNT_PATH=${mount_path}"
                echo "${name}_PERMISSIONS=${permissions}"
            } | flyctl secrets import -a "$app_name"
        done < "$FILE_SECRETS_CACHE"
    fi

    print_success "Secrets injected into Fly.io"
    return 0
}

#######################################
# Get file secrets for Docker Compose
# Outputs Docker secrets YAML section
#######################################
secrets_get_docker_files() {
    if [[ ! -f "$FILE_SECRETS_CACHE" ]] || [[ ! -s "$FILE_SECRETS_CACHE" ]]; then
        return 0
    fi

    echo "secrets:"
    while IFS='|' read -r name type path mount_path permissions content_b64; do
        echo "  ${name,,}:"
        echo "    file: $path"
    done < "$FILE_SECRETS_CACHE"
}

#######################################
# Get file secret mounts for Docker service
# Outputs Docker service secrets section
#######################################
secrets_get_docker_mounts() {
    if [[ ! -f "$FILE_SECRETS_CACHE" ]] || [[ ! -s "$FILE_SECRETS_CACHE" ]]; then
        return 0
    fi

    echo "    secrets:"
    while IFS='|' read -r name type path mount_path permissions content_b64; do
        # Convert octal permissions to decimal for Docker
        local mode_decimal
        mode_decimal=$((8#${permissions}))
        echo "      - source: ${name,,}"
        echo "        target: $mount_path"
        echo "        mode: $mode_decimal"
    done < "$FILE_SECRETS_CACHE"
}

#######################################
# Generate Kubernetes Secret YAML
# Arguments:
#   $1 - Secret name (default: sindri-secrets)
#   $2 - Namespace (default: default)
# Outputs:
#   Kubernetes Secret YAML to stdout
#######################################
secrets_generate_k8s() {
    local secret_name="${1:-sindri-secrets}"
    local namespace="${2:-default}"

    cat <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: $secret_name
  namespace: $namespace
type: Opaque
data:
EOF

    if [[ -f "$SECRETS_CACHE" ]] && [[ -s "$SECRETS_CACHE" ]]; then
        while IFS='=' read -r key value; do
            # Base64 encode the value
            local encoded
            encoded=$(echo -n "$value" | base64 | tr -d '\n')
            echo "  $key: $encoded"
        done < "$SECRETS_CACHE"
    fi
}

#######################################
# Generate Kubernetes file secrets YAML
# Arguments:
#   $1 - Secret name (default: sindri-file-secrets)
#   $2 - Namespace (default: default)
# Outputs:
#   Kubernetes Secret YAML to stdout
#######################################
secrets_generate_k8s_files() {
    local secret_name="${1:-sindri-file-secrets}"
    local namespace="${2:-default}"

    if [[ ! -f "$FILE_SECRETS_CACHE" ]] || [[ ! -s "$FILE_SECRETS_CACHE" ]]; then
        return 0
    fi

    cat <<EOF
---
apiVersion: v1
kind: Secret
metadata:
  name: $secret_name
  namespace: $namespace
type: Opaque
data:
EOF

    while IFS='|' read -r name type path mount_path permissions content_b64; do
        local filename
        filename=$(basename "$mount_path")
        echo "  $filename: $content_b64"
    done < "$FILE_SECRETS_CACHE"
}

#######################################
# Generate devcontainer.json environment section
# Outputs JSON containerEnv section
#######################################
secrets_generate_devcontainer_env() {
    if [[ ! -f "$SECRETS_CACHE" ]] || [[ ! -s "$SECRETS_CACHE" ]]; then
        echo "  \"containerEnv\": {}"
        return 0
    fi

    echo "  \"containerEnv\": {"
    local first=true
    while IFS='=' read -r key value; do
        if [[ "$first" == "true" ]]; then
            first=false
        else
            echo ","
        fi
        echo -n "    \"$key\": \"\${localEnv:$key}\""
    done < "$SECRETS_CACHE"
    echo ""
    echo "  }"
}

#######################################
# List configured secrets
# Arguments:
#   $1 - Path to sindri.yaml (default: sindri.yaml)
#######################################
secrets_list() {
    local config="${1:-sindri.yaml}"

    if [[ ! -f "$config" ]]; then
        print_error "Configuration file not found: $config"
        return 1
    fi

    print_header "Configured secrets in $config"

    local secrets_count
    secrets_count=$(yq '.secrets | length' "$config" 2>/dev/null || echo "0")

    if [[ "$secrets_count" == "0" ]] || [[ "$secrets_count" == "null" ]]; then
        print_status "No secrets configured"
        return 0
    fi

    # Group by source type
    local env_secrets file_secrets vault_secrets
    env_secrets=$(yq '.secrets[] | select(.source == "env") | .name' "$config" 2>/dev/null || true)
    file_secrets=$(yq '.secrets[] | select(.source == "file")' "$config" -o=json 2>/dev/null || true)
    vault_secrets=$(yq '.secrets[] | select(.source == "vault")' "$config" -o=json 2>/dev/null || true)

    if [[ -n "$env_secrets" ]]; then
        echo ""
        print_status "Environment Variables (source: env):"
        echo "$env_secrets" | while read -r name; do
            local required from_file info=""
            required=$(yq ".secrets[] | select(.name == \"$name\") | .required // false" "$config")
            from_file=$(yq ".secrets[] | select(.name == \"$name\") | .fromFile // \"\"" "$config")
            if [[ "$required" == "true" ]]; then
                info="required"
            fi
            if [[ -n "$from_file" ]]; then
                if [[ -n "$info" ]]; then
                    info="$info, fromFile: $from_file"
                else
                    info="fromFile: $from_file"
                fi
            fi
            if [[ -n "$info" ]]; then
                echo "  • $name ($info)"
            else
                echo "  • $name"
            fi
        done
    fi

    if [[ -n "$file_secrets" ]]; then
        echo ""
        print_status "Files (source: file):"
        echo "$file_secrets" | jq -c '.' | while read -r secret; do
            local name mount_path permissions
            name=$(echo "$secret" | jq -r '.name')
            mount_path=$(echo "$secret" | jq -r '.mountPath')
            permissions=$(echo "$secret" | jq -r '.permissions // "0644"')
            echo "  • $name → $mount_path ($permissions)"
        done
    fi

    if [[ -n "$vault_secrets" ]]; then
        echo ""
        print_status "Vault (source: vault):"
        echo "$vault_secrets" | jq -c '.' | while read -r secret; do
            local name vault_path vault_key required
            name=$(echo "$secret" | jq -r '.name')
            vault_path=$(echo "$secret" | jq -r '.vaultPath')
            vault_key=$(echo "$secret" | jq -r '.vaultKey')
            required=$(echo "$secret" | jq -r '.required // false')
            if [[ "$required" == "true" ]]; then
                echo "  • $name ← $vault_path:$vault_key (required)"
            else
                echo "  • $name ← $vault_path:$vault_key"
            fi
        done
    fi

    echo ""
}

#######################################
# Test Vault connection
#######################################
secrets_test_vault() {
    print_header "Testing Vault connection"

    # Check Vault CLI
    if ! command -v vault &> /dev/null; then
        print_error "✗ Vault CLI not installed"
        print_status "  Install: https://www.vaultproject.io/downloads"
        return 1
    fi
    print_success "✓ Vault CLI installed"

    # Check VAULT_ADDR
    if [[ -z "${VAULT_ADDR:-}" ]]; then
        print_error "✗ VAULT_ADDR not set"
        print_status "  Set with: export VAULT_ADDR='https://vault.example.com'"
        return 1
    fi
    print_success "✓ VAULT_ADDR set: $VAULT_ADDR"

    # Check VAULT_TOKEN
    if [[ -z "${VAULT_TOKEN:-}" ]] && [[ ! -f ~/.vault-token ]]; then
        print_error "✗ VAULT_TOKEN not set and ~/.vault-token not found"
        print_status "  Set with: export VAULT_TOKEN='hvs.xxx'"
        return 1
    fi
    print_success "✓ VAULT_TOKEN set"

    # H-8 Security Fix: Validate and renew token
    if ! vault_token_validate_and_renew; then
        return 1
    fi

    # Test connection
    if ! vault status &> /dev/null; then
        print_error "✗ Vault connection failed"
        print_status "  Check VAULT_ADDR and VAULT_TOKEN"
        return 1
    fi
    print_success "✓ Vault connection successful"

    # Check KV v2 engine
    if vault secrets list -format=json 2>/dev/null | jq -e '.["secret/"] | .type == "kv"' > /dev/null; then
        print_success "✓ KV v2 engine enabled at secret/"
    else
        print_warning "⚠ KV v2 engine not found at secret/"
    fi

    echo ""
    print_success "Vault connection test passed"
}

#######################################
# Encode file to base64
# Arguments:
#   $1 - File path
#######################################
secrets_encode_file() {
    local file_path="$1"

    if [[ ! -f "$file_path" ]]; then
        print_error "File not found: $file_path"
        return 1
    fi

    print_header "Base64-encoding file: $file_path"

    local encoded
    encoded=$(base64 < "$file_path" | tr -d '\n')

    echo ""
    print_status "Base64-encoded content (copy for manual secret setting):"
    echo "$encoded"

    echo ""
    print_status "To set manually on Fly.io:"
    local name
    name=$(basename "$file_path" | tr '.' '_' | tr '[:lower:]' '[:upper:]')
    echo "flyctl secrets set ${name}_BASE64='${encoded}' -a <app-name>"
}

# Export functions for use by adapters and CLI
export -f secrets_resolve_all
export -f secrets_validate
export -f secrets_list
export -f secrets_test_vault
export -f secrets_encode_file
export -f secrets_generate_env
export -f secrets_inject_fly
export -f secrets_get_docker_files
export -f secrets_get_docker_mounts
export -f secrets_generate_k8s
export -f secrets_generate_k8s_files
export -f secrets_generate_devcontainer_env
