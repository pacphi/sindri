#!/bin/bash
# Secrets Manager - Centralized secret resolution for all providers
#
# This module provides secret resolution from multiple sources:
# - env: Environment variables and .env files
# - file: Files (certificates, keys, configs)
# - vault: HashiCorp Vault KV store
#
# Public API:
#   secrets_resolve_all      - Resolve all secrets from sindri.yaml
#   secrets_validate         - Validate all secrets are available
#   secrets_generate_env     - Generate .env file for provider
#   secrets_inject_fly       - Inject secrets into Fly.io
#   secrets_inject_docker    - Generate docker-compose secrets config
#   secrets_inject_k8s       - Generate Kubernetes Secret YAML
#   secrets_inject_devpod    - Generate devcontainer.json env config

set -euo pipefail

# Get script directory
SECRETS_MANAGER_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source common utilities
# shellcheck source=../docker/lib/common.sh
source "${SECRETS_MANAGER_DIR}/../docker/lib/common.sh"

# Temporary files for secret storage (in memory if possible)
SECRETS_CACHE="${TMPDIR:-/tmp}/sindri-secrets-$$"
FILE_SECRETS_CACHE="${TMPDIR:-/tmp}/sindri-file-secrets-$$"
VALIDATION_ERRORS=0

# Cleanup on exit
cleanup_secrets() {
    rm -f "$SECRETS_CACHE" "$FILE_SECRETS_CACHE"
}
trap cleanup_secrets EXIT

#######################################
# Resolve all secrets from sindri.yaml
# Arguments:
#   $1 - Path to sindri.yaml (default: sindri.yaml)
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_resolve_all() {
    local config="${1:-sindri.yaml}"

    if [[ ! -f "$config" ]]; then
        print_error "Configuration file not found: $config"
        return 1
    fi

    # Initialize cache files
    : > "$SECRETS_CACHE"
    : > "$FILE_SECRETS_CACHE"

    # Check if secrets are defined
    local secrets_count
    secrets_count=$(yq '.secrets | length' "$config" 2>/dev/null || echo "0")

    if [[ "$secrets_count" == "0" ]] || [[ "$secrets_count" == "null" ]]; then
        print_status "No secrets configured in $config"
        return 0
    fi

    print_status "Resolving $secrets_count secret(s)..."

    # Process each secret
    local i
    for ((i=0; i<secrets_count; i++)); do
        local secret_json
        secret_json=$(yq ".secrets[$i]" -o=json "$config")

        local name source
        name=$(echo "$secret_json" | jq -r '.name')
        source=$(echo "$secret_json" | jq -r '.source')

        case "$source" in
            env)
                _resolve_env_secret "$secret_json" "$config"
                ;;
            file)
                _resolve_file_secret "$secret_json" "$config"
                ;;
            vault)
                _resolve_vault_secret "$secret_json" "$config"
                ;;
            *)
                print_error "Unknown secret source '$source' for $name"
                return 1
                ;;
        esac
    done

    if [[ $VALIDATION_ERRORS -gt 0 ]]; then
        print_error "Failed to resolve $VALIDATION_ERRORS secret(s)"
        return 1
    fi

    print_success "All secrets resolved successfully"
    return 0
}

#######################################
# Resolve environment variable secret
# Arguments:
#   $1 - Secret JSON object
#   $2 - Path to sindri.yaml
# Returns:
#   0 on success, 1 on failure
#######################################
_resolve_env_secret() {
    local secret="$1"
    local config="$2"
    local name value required

    name=$(echo "$secret" | jq -r '.name')
    required=$(echo "$secret" | jq -r '.required // false')

    # Priority: shell env > .env.local > .env
    if [[ -n "${!name:-}" ]]; then
        value="${!name}"
        print_status "  ✓ $name (from shell environment)"
    elif [[ -f .env.local ]] && grep -q "^${name}=" .env.local 2>/dev/null; then
        value=$(grep "^${name}=" .env.local | head -1 | cut -d= -f2-)
        # Remove quotes if present
        value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
        print_status "  ✓ $name (from .env.local)"
    elif [[ -f .env ]] && grep -q "^${name}=" .env 2>/dev/null; then
        value=$(grep "^${name}=" .env | head -1 | cut -d= -f2-)
        # Remove quotes if present
        value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
        print_status "  ✓ $name (from .env)"
    fi

    if [[ -z "${value:-}" ]]; then
        if [[ "$required" == "true" ]]; then
            print_error "  ✗ Required secret $name not found"
            print_status "    Checked: \$$name, .env.local, .env"
            print_status "    Hint: export $name=<value> or add to .env.local"
            ((VALIDATION_ERRORS++))
            return 1
        else
            print_warning "  ⚠ Optional secret $name not found (will not be set)"
            return 0
        fi
    fi

    # Output to resolved secrets cache
    echo "${name}=${value}" >> "$SECRETS_CACHE"
    return 0
}

#######################################
# Resolve file secret
# Arguments:
#   $1 - Secret JSON object
#   $2 - Path to sindri.yaml
# Returns:
#   0 on success, 1 on failure
#######################################
_resolve_file_secret() {
    local secret="$1"
    local config="$2"
    local name path mount_path permissions required

    name=$(echo "$secret" | jq -r '.name')
    path=$(echo "$secret" | jq -r '.path')
    mount_path=$(echo "$secret" | jq -r '.mountPath // ""')
    permissions=$(echo "$secret" | jq -r '.permissions // "0644"')
    required=$(echo "$secret" | jq -r '.required // false')

    # Expand ~ and relative paths
    path="${path/#\~/$HOME}"
    if [[ ! "$path" =~ ^/ ]]; then
        # Relative path - make absolute relative to config directory
        local config_dir
        config_dir="$(cd "$(dirname "$config")" && pwd)"
        path="${config_dir}/${path}"
    fi

    if [[ ! -f "$path" ]]; then
        if [[ "$required" == "true" ]]; then
            print_error "  ✗ Secret file not found: $path"
            ((VALIDATION_ERRORS++))
            return 1
        else
            print_warning "  ⚠ Optional secret file not found: $path (will not be set)"
            return 0
        fi
    fi

    # Get file size for display
    local size
    if [[ "$OSTYPE" == "darwin"* ]]; then
        size=$(stat -f%z "$path")
    else
        size=$(stat -c%s "$path")
    fi

    # Base64 encode for safe transport
    local content_b64
    content_b64=$(base64 < "$path" | tr -d '\n')

    print_status "  ✓ $name (file: $path, ${size} bytes)"

    # Store metadata: name|file|path|mount_path|permissions|base64_content
    echo "${name}|file|${path}|${mount_path}|${permissions}|${content_b64}" >> "$FILE_SECRETS_CACHE"
    return 0
}

#######################################
# Resolve Vault secret
# Arguments:
#   $1 - Secret JSON object
#   $2 - Path to sindri.yaml
# Returns:
#   0 on success, 1 on failure
#######################################
_resolve_vault_secret() {
    local secret="$1"
    local config="$2"
    local name vault_path vault_key vault_mount value required

    name=$(echo "$secret" | jq -r '.name')
    vault_path=$(echo "$secret" | jq -r '.vaultPath')
    vault_key=$(echo "$secret" | jq -r '.vaultKey')
    vault_mount=$(echo "$secret" | jq -r '.vaultMount // "secret"')
    required=$(echo "$secret" | jq -r '.required // false')

    # Check Vault CLI availability
    if ! command -v vault &> /dev/null; then
        print_error "  ✗ vault CLI not found (required for $name)"
        print_status "    Install: https://www.vaultproject.io/downloads"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++))
            return 1
        fi
        return 0
    fi

    # Check authentication
    if [[ -z "${VAULT_ADDR:-}" ]]; then
        print_error "  ✗ VAULT_ADDR not set (required for $name)"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++))
            return 1
        fi
        return 0
    fi

    if [[ -z "${VAULT_TOKEN:-}" ]] && [[ ! -f ~/.vault-token ]]; then
        print_error "  ✗ VAULT_TOKEN not set and ~/.vault-token not found"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++))
            return 1
        fi
        return 0
    fi

    # Retrieve secret
    value=$(vault kv get -mount="$vault_mount" -field="$vault_key" "$vault_path" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$value" ]]; then
        print_error "  ✗ Failed to retrieve $name from Vault"
        print_status "    Path: $vault_mount/$vault_path"
        print_status "    Key: $vault_key"
        if [[ "$required" == "true" ]]; then
            ((VALIDATION_ERRORS++))
            return 1
        fi
        return 0
    fi

    print_status "  ✓ $name (from vault:$vault_mount/$vault_path)"
    echo "${name}=${value}" >> "$SECRETS_CACHE"
    return 0
}

#######################################
# Validate all secrets without resolving
# Arguments:
#   $1 - Path to sindri.yaml (default: sindri.yaml)
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_validate() {
    local config="${1:-sindri.yaml}"

    print_header "Validating secrets from $config"

    VALIDATION_ERRORS=0
    secrets_resolve_all "$config"

    if [[ $VALIDATION_ERRORS -eq 0 ]]; then
        print_success "All secrets validated successfully"
        return 0
    else
        print_error "Validation failed: $VALIDATION_ERRORS error(s)"
        return 1
    fi
}

#######################################
# Generate .env file from resolved secrets
# Arguments:
#   $1 - Output file path (default: .env.secrets)
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_generate_env() {
    local output="${1:-.env.secrets}"

    if [[ ! -f "$SECRETS_CACHE" ]]; then
        print_error "No secrets resolved. Run secrets_resolve_all first."
        return 1
    fi

    cp "$SECRETS_CACHE" "$output"
    chmod 600 "$output"

    print_success "Generated environment file: $output"
    return 0
}

#######################################
# Inject secrets into Fly.io app
# Arguments:
#   $1 - Fly.io app name
# Returns:
#   0 on success, 1 on failure
#######################################
secrets_inject_fly() {
    local app_name="$1"

    if [[ ! -f "$SECRETS_CACHE" ]]; then
        print_status "No environment secrets to inject"
    else
        print_status "Injecting secrets into Fly.io app: $app_name"

        # Use flyctl secrets import for atomic update
        flyctl secrets import -a "$app_name" < "$SECRETS_CACHE"
    fi

    # Handle file secrets
    if [[ -f "$FILE_SECRETS_CACHE" ]] && [[ -s "$FILE_SECRETS_CACHE" ]]; then
        print_status "Injecting file secrets (base64 encoded)..."

        while IFS='|' read -r name type path mount_path permissions content_b64; do
            flyctl secrets set "${name}_BASE64=${content_b64}" -a "$app_name"
            flyctl secrets set "${name}_MOUNT_PATH=${mount_path}" -a "$app_name"
            flyctl secrets set "${name}_PERMISSIONS=${permissions}" -a "$app_name"
        done < "$FILE_SECRETS_CACHE"
    fi

    print_success "Secrets injected into Fly.io"
    return 0
}

#######################################
# Get file secrets for Docker Compose
# Outputs Docker secrets YAML section
#######################################
secrets_get_docker_files() {
    if [[ ! -f "$FILE_SECRETS_CACHE" ]] || [[ ! -s "$FILE_SECRETS_CACHE" ]]; then
        return 0
    fi

    echo "secrets:"
    while IFS='|' read -r name type path mount_path permissions content_b64; do
        echo "  ${name,,}:"
        echo "    file: $path"
    done < "$FILE_SECRETS_CACHE"
}

#######################################
# Get file secret mounts for Docker service
# Outputs Docker service secrets section
#######################################
secrets_get_docker_mounts() {
    if [[ ! -f "$FILE_SECRETS_CACHE" ]] || [[ ! -s "$FILE_SECRETS_CACHE" ]]; then
        return 0
    fi

    echo "    secrets:"
    while IFS='|' read -r name type path mount_path permissions content_b64; do
        # Convert octal permissions to decimal for Docker
        local mode_decimal
        mode_decimal=$((8#${permissions}))
        echo "      - source: ${name,,}"
        echo "        target: $mount_path"
        echo "        mode: $mode_decimal"
    done < "$FILE_SECRETS_CACHE"
}

#######################################
# Generate Kubernetes Secret YAML
# Arguments:
#   $1 - Secret name (default: sindri-secrets)
#   $2 - Namespace (default: default)
# Outputs:
#   Kubernetes Secret YAML to stdout
#######################################
secrets_generate_k8s() {
    local secret_name="${1:-sindri-secrets}"
    local namespace="${2:-default}"

    cat <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: $secret_name
  namespace: $namespace
type: Opaque
data:
EOF

    if [[ -f "$SECRETS_CACHE" ]] && [[ -s "$SECRETS_CACHE" ]]; then
        while IFS='=' read -r key value; do
            # Base64 encode the value
            local encoded
            encoded=$(echo -n "$value" | base64 | tr -d '\n')
            echo "  $key: $encoded"
        done < "$SECRETS_CACHE"
    fi
}

#######################################
# Generate Kubernetes file secrets YAML
# Arguments:
#   $1 - Secret name (default: sindri-file-secrets)
#   $2 - Namespace (default: default)
# Outputs:
#   Kubernetes Secret YAML to stdout
#######################################
secrets_generate_k8s_files() {
    local secret_name="${1:-sindri-file-secrets}"
    local namespace="${2:-default}"

    if [[ ! -f "$FILE_SECRETS_CACHE" ]] || [[ ! -s "$FILE_SECRETS_CACHE" ]]; then
        return 0
    fi

    cat <<EOF
---
apiVersion: v1
kind: Secret
metadata:
  name: $secret_name
  namespace: $namespace
type: Opaque
data:
EOF

    while IFS='|' read -r name type path mount_path permissions content_b64; do
        local filename
        filename=$(basename "$mount_path")
        echo "  $filename: $content_b64"
    done < "$FILE_SECRETS_CACHE"
}

#######################################
# Generate devcontainer.json environment section
# Outputs JSON containerEnv section
#######################################
secrets_generate_devcontainer_env() {
    if [[ ! -f "$SECRETS_CACHE" ]] || [[ ! -s "$SECRETS_CACHE" ]]; then
        echo "  \"containerEnv\": {}"
        return 0
    fi

    echo "  \"containerEnv\": {"
    local first=true
    while IFS='=' read -r key value; do
        if [[ "$first" == "true" ]]; then
            first=false
        else
            echo ","
        fi
        echo -n "    \"$key\": \"\${localEnv:$key}\""
    done < "$SECRETS_CACHE"
    echo ""
    echo "  }"
}

#######################################
# List configured secrets
# Arguments:
#   $1 - Path to sindri.yaml (default: sindri.yaml)
#######################################
secrets_list() {
    local config="${1:-sindri.yaml}"

    if [[ ! -f "$config" ]]; then
        print_error "Configuration file not found: $config"
        return 1
    fi

    print_header "Configured secrets in $config"

    local secrets_count
    secrets_count=$(yq '.secrets | length' "$config" 2>/dev/null || echo "0")

    if [[ "$secrets_count" == "0" ]] || [[ "$secrets_count" == "null" ]]; then
        print_status "No secrets configured"
        return 0
    fi

    # Group by source type
    local env_secrets file_secrets vault_secrets
    env_secrets=$(yq '.secrets[] | select(.source == "env") | .name' "$config" 2>/dev/null || true)
    file_secrets=$(yq '.secrets[] | select(.source == "file")' "$config" -o=json 2>/dev/null || true)
    vault_secrets=$(yq '.secrets[] | select(.source == "vault")' "$config" -o=json 2>/dev/null || true)

    if [[ -n "$env_secrets" ]]; then
        echo ""
        print_status "Environment Variables (source: env):"
        echo "$env_secrets" | while read -r name; do
            local required
            required=$(yq ".secrets[] | select(.name == \"$name\") | .required // false" "$config")
            if [[ "$required" == "true" ]]; then
                echo "  • $name (required)"
            else
                echo "  • $name"
            fi
        done
    fi

    if [[ -n "$file_secrets" ]]; then
        echo ""
        print_status "Files (source: file):"
        echo "$file_secrets" | jq -c '.' | while read -r secret; do
            local name mount_path permissions
            name=$(echo "$secret" | jq -r '.name')
            mount_path=$(echo "$secret" | jq -r '.mountPath')
            permissions=$(echo "$secret" | jq -r '.permissions // "0644"')
            echo "  • $name → $mount_path ($permissions)"
        done
    fi

    if [[ -n "$vault_secrets" ]]; then
        echo ""
        print_status "Vault (source: vault):"
        echo "$vault_secrets" | jq -c '.' | while read -r secret; do
            local name vault_path vault_key required
            name=$(echo "$secret" | jq -r '.name')
            vault_path=$(echo "$secret" | jq -r '.vaultPath')
            vault_key=$(echo "$secret" | jq -r '.vaultKey')
            required=$(echo "$secret" | jq -r '.required // false')
            if [[ "$required" == "true" ]]; then
                echo "  • $name ← $vault_path:$vault_key (required)"
            else
                echo "  • $name ← $vault_path:$vault_key"
            fi
        done
    fi

    echo ""
}

#######################################
# Test Vault connection
#######################################
secrets_test_vault() {
    print_header "Testing Vault connection"

    # Check Vault CLI
    if ! command -v vault &> /dev/null; then
        print_error "✗ Vault CLI not installed"
        print_status "  Install: https://www.vaultproject.io/downloads"
        return 1
    fi
    print_success "✓ Vault CLI installed"

    # Check VAULT_ADDR
    if [[ -z "${VAULT_ADDR:-}" ]]; then
        print_error "✗ VAULT_ADDR not set"
        print_status "  Set with: export VAULT_ADDR='https://vault.example.com'"
        return 1
    fi
    print_success "✓ VAULT_ADDR set: $VAULT_ADDR"

    # Check VAULT_TOKEN
    if [[ -z "${VAULT_TOKEN:-}" ]] && [[ ! -f ~/.vault-token ]]; then
        print_error "✗ VAULT_TOKEN not set and ~/.vault-token not found"
        print_status "  Set with: export VAULT_TOKEN='hvs.xxx'"
        return 1
    fi
    print_success "✓ VAULT_TOKEN set"

    # Test connection
    if ! vault status &> /dev/null; then
        print_error "✗ Vault connection failed"
        print_status "  Check VAULT_ADDR and VAULT_TOKEN"
        return 1
    fi
    print_success "✓ Vault connection successful"

    # Check KV v2 engine
    if vault secrets list -format=json 2>/dev/null | jq -e '.["secret/"] | .type == "kv"' > /dev/null; then
        print_success "✓ KV v2 engine enabled at secret/"
    else
        print_warning "⚠ KV v2 engine not found at secret/"
    fi

    echo ""
    print_success "Vault connection test passed"
}

#######################################
# Encode file to base64
# Arguments:
#   $1 - File path
#######################################
secrets_encode_file() {
    local file_path="$1"

    if [[ ! -f "$file_path" ]]; then
        print_error "File not found: $file_path"
        return 1
    fi

    print_header "Base64-encoding file: $file_path"

    local encoded
    encoded=$(base64 < "$file_path" | tr -d '\n')

    echo ""
    print_status "Base64-encoded content (copy for manual secret setting):"
    echo "$encoded"

    echo ""
    print_status "To set manually on Fly.io:"
    local name
    name=$(basename "$file_path" | tr '.' '_' | tr '[:lower:]' '[:upper:]')
    echo "flyctl secrets set ${name}_BASE64='${encoded}' -a <app-name>"
}

# Export functions for use by adapters and CLI
export -f secrets_resolve_all
export -f secrets_validate
export -f secrets_list
export -f secrets_test_vault
export -f secrets_encode_file
export -f secrets_generate_env
export -f secrets_inject_fly
export -f secrets_get_docker_files
export -f secrets_get_docker_mounts
export -f secrets_generate_k8s
export -f secrets_generate_k8s_files
export -f secrets_generate_devcontainer_env
