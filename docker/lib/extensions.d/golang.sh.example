#!/bin/bash
# golang.sh.example - Go toolchain and development tools
# Extension API v1.0
#
# This extension installs Go with:
# - Go toolchain from official releases
# - Development tools (gopls, delve, golangci-lint, air)
# - Project template generator
# - CI mode detection for lightweight installs

# Source shared extension library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$(dirname "$SCRIPT_DIR")/extensions-common.sh"

# ============================================================================
# METADATA
# ============================================================================

EXT_NAME="golang"
EXT_VERSION="1.0.0"
EXT_DESCRIPTION="Go toolchain with development tools"
EXT_CATEGORY="language"

# Initialize extension environment
extension_init

# ============================================================================
# PREREQUISITES
# ============================================================================

prerequisites() {
  print_status "Checking prerequisites for ${EXT_NAME}..."

  # Check for wget
  if ! command_exists wget; then
    print_error "wget is required but not installed"
    print_status "Install with: sudo apt-get install wget"
    return 1
  fi

  # Check for sudo
  if ! command_exists sudo; then
    print_error "sudo is required but not installed"
    return 1
  fi

  # Check disk space (Go needs ~500MB)
  local available_space
  available_space=$(df -BM /usr/local 2>/dev/null | awk 'NR==2 {print $4}' | sed 's/M//')
  if [[ -n "$available_space" ]] && [[ $available_space -lt 600 ]]; then
    print_warning "Low disk space: ${available_space}MB available (600MB recommended for Go)"
  fi

  print_success "All prerequisites met"
  return 0
}

# ============================================================================
# INSTALL
# ============================================================================

install() {
  print_status "Installing Go toolchain..."

  # Check if Go is already installed
  if command_exists go; then
    local go_version
    go_version=$(go version 2>/dev/null)
    print_warning "Go is already installed: $go_version"
    print_status "Skipping installation (remove first to reinstall)"
    return 0
  fi

  # Install Go
  local GO_VERSION="1.24.6"
  local GO_ARCHIVE="go${GO_VERSION}.linux-amd64.tar.gz"

  print_status "Downloading Go $GO_VERSION..."
  if wget -q "https://go.dev/dl/$GO_ARCHIVE"; then
    print_status "Extracting Go..."
    sudo tar -C /usr/local -xzf "$GO_ARCHIVE"
    rm "$GO_ARCHIVE"
    print_success "Go installed: $GO_VERSION"
  else
    print_error "Failed to download Go"
    return 1
  fi

  # Check if running in CI mode
  if [[ "$CI_MODE" == "true" ]]; then
    print_status "CI mode detected - skipping Go development tools"
    return 0
  fi

  # Set up environment for tool installation
  export PATH=$PATH:/usr/local/go/bin
  export GOPATH=$HOME/go
  export GOBIN=$GOPATH/bin
  export PATH=$PATH:$GOBIN

  # Ensure GOBIN directory exists
  mkdir -p "$GOBIN"

  # Install Go development tools
  print_status "Installing Go development tools..."
  local go_tools=(
    "golang.org/x/tools/gopls@latest"
    "github.com/go-delve/delve/cmd/dlv@latest"
    "golang.org/x/tools/cmd/goimports@latest"
    "github.com/golangci/golangci-lint/cmd/golangci-lint@latest"
    "github.com/air-verse/air@latest"
    "github.com/goreleaser/goreleaser@latest"
  )

  local installed_count=0
  for tool in "${go_tools[@]}"; do
    local tool_name=$(basename "$tool" | cut -d'@' -f1)
    print_debug "Installing $tool_name..."
    if timeout 300 go install "$tool" 2>&1 | grep -v "^go: downloading"; then
      if command_exists "$tool_name"; then
        print_debug "✓ $tool_name installed"
        ((installed_count++))
      else
        print_warning "Failed to install $tool_name - binary not found after installation"
      fi
    else
      print_warning "Failed to install $tool_name - go install command failed"
    fi
  done

  print_status "Installed $installed_count/${#go_tools[@]} development tools"
  return 0
}

# ============================================================================
# CONFIGURE
# ============================================================================

configure() {
  print_status "Configuring Go environment..."

  # Configure PATH for SSH sessions
  if command_exists setup_tool_path 2>/dev/null; then
    setup_tool_path "golang" \
      'export PATH=$PATH:/usr/local/go/bin' \
      'export GOPATH=$HOME/go; export PATH=$PATH:$GOPATH/bin'
  else
    # Fallback: add to bashrc
    if ! grep -q "/usr/local/go/bin" "$HOME/.bashrc" 2>/dev/null; then
      echo "" >> "$HOME/.bashrc"
      echo "# ${EXT_NAME} - Go toolchain" >> "$HOME/.bashrc"
      echo 'export PATH=$PATH:/usr/local/go/bin' >> "$HOME/.bashrc"
      echo 'export GOPATH=$HOME/go' >> "$HOME/.bashrc"
      echo 'export PATH=$PATH:$GOPATH/bin' >> "$HOME/.bashrc"
      print_success "Added Go to PATH"
    fi
  fi

  # Set for current session
  export PATH=$PATH:/usr/local/go/bin
  export GOPATH=$HOME/go
  export PATH=$PATH:$GOPATH/bin

  # Create SSH wrappers
  if command_exists create_tool_wrapper 2>/dev/null; then
    create_tool_wrapper "go" "/usr/local/go/bin/go"
    create_tool_wrapper "gofmt" "/usr/local/go/bin/gofmt"
    [[ -f "/usr/local/go/bin/godoc" ]] && create_tool_wrapper "godoc" "/usr/local/go/bin/godoc"
  fi

  # Create Go project template script
  print_status "Creating Go project template..."
  cat > /workspace/scripts/create-go-project.sh << 'EOF'
#!/bin/bash
# Create a new Go project with module initialization

project_name="$1"
if [[ -z "$project_name" ]]; then
    echo "Usage: $0 <project-name>"
    exit 1
fi

mkdir -p "/workspace/projects/active/$project_name"
cd "/workspace/projects/active/$project_name"

go mod init "github.com/user/$project_name"

mkdir -p cmd pkg internal

cat > cmd/main.go << 'MAIN'
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
MAIN

cat > Makefile << 'MAKEFILE'
.PHONY: build run test clean

build:
	go build -o bin/$(shell basename $(CURDIR)) ./cmd

run:
	go run ./cmd

test:
	go test -v ./...

clean:
	rm -rf bin/

lint:
	golangci-lint run

fmt:
	go fmt ./...
	goimports -w .
MAKEFILE

cat > README.md << README
# $project_name

## Build
\`\`\`bash
make build
\`\`\`

## Run
\`\`\`bash
make run
\`\`\`

## Test
\`\`\`bash
make test
\`\`\`

## Development
\`\`\`bash
# Hot reload with air
air
\`\`\`
README

cat > .air.toml << 'AIR'
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"

[build]
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main ./cmd"
  delay = 1000
  exclude_dir = ["assets", "tmp", "vendor", "testdata"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  exclude_unchanged = false
  follow_symlink = false
  full_bin = ""
  include_dir = []
  include_ext = ["go", "tpl", "tmpl", "html"]
  kill_delay = "0s"
  log = "build-errors.log"
  send_interrupt = false
  stop_on_error = true

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"
AIR

echo "Go project '$project_name' created successfully!"
echo "To run: cd /workspace/projects/active/$project_name && make run"
EOF

  chmod +x /workspace/scripts/create-go-project.sh
  print_success "Project template created"

  # Add Git aliases
  if command_exists git; then
    git config --global alias.gotest '!go test ./...'
    git config --global alias.gofmt '!go fmt ./... && goimports -w .'
    print_debug "Git aliases configured"
  fi

  print_success "Go configured"
  return 0
}

# ============================================================================
# VALIDATE
# ============================================================================

validate() {
  print_status "Validating Go installation..."

  local all_valid=true

  # Check go command
  if ! command_exists go; then
    print_error "go command not found"
    all_valid=false
  else
    print_success "Go: $(go version)"
  fi

  # Check GOPATH
  if [[ -n "$GOPATH" ]]; then
    print_success "GOPATH: $GOPATH"
  else
    print_warning "GOPATH not set"
  fi

  # Check development tools
  local tools=(gopls dlv goimports golangci-lint air goreleaser)
  local tools_found=0
  for tool in "${tools[@]}"; do
    command_exists "$tool" && ((tools_found++))
  done
  print_status "Development tools: $tools_found/${#tools[@]}"

  # Check project template
  [[ -f "/workspace/scripts/create-go-project.sh" ]] && print_success "Project template: installed"

  if [[ "$all_valid" == "true" ]]; then
    print_success "Validation passed"
    return 0
  else
    print_error "Validation failed"
    return 1
  fi
}

# ============================================================================
# STATUS
# ============================================================================

status() {
  print_status "Checking Go status..."

  if ! command_exists go; then
    print_warning "Go not installed"
    return 1
  fi

  print_success "Go: $(go version)"
  if [[ -n "$GOPATH" ]]; then
    print_success "GOPATH: $GOPATH"
  else
    print_warning "GOPATH not set"
  fi

  # Show installed tools
  print_status "Installed development tools:"
  local tools=(gopls dlv goimports golangci-lint air goreleaser)
  for tool in "${tools[@]}"; do
    command_exists "$tool" && echo "  ✓ $tool"
  done

  [[ -f "/workspace/scripts/create-go-project.sh" ]] && print_success "Project template: installed"

  return 0
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

check_dependent_extensions() {
  local provided_commands=("$@")
  local dependent_extensions=()
  local manifest_file="$SCRIPT_DIR/active-extensions.conf"
  [[ ! -f "$manifest_file" ]] && manifest_file="/workspace/scripts/extensions.d/active-extensions.conf"
  [[ ! -f "$manifest_file" ]] && return 0

  while IFS= read -r line; do
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// }" ]] && continue
    local ext_name=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    [[ "$ext_name" == "$EXT_NAME" ]] && continue
    local ext_file="$SCRIPT_DIR/${ext_name}.sh"
    if [[ ! -f "$ext_file" ]]; then
      local matches=("$SCRIPT_DIR/"*"-${ext_name}.sh")
      ext_file="${matches[0]}"
    fi
    [[ ! -f "$ext_file" ]] && continue
    for cmd in "${provided_commands[@]}"; do
      if grep -q "$cmd" "$ext_file" 2>/dev/null; then
        dependent_extensions+=("$ext_name")
        break
      fi
    done
  done < "$manifest_file"

  printf '%s\n' "${dependent_extensions[@]}"
}

# ============================================================================
# REMOVE
# ============================================================================

remove() {
  print_warning "Uninstalling Go..."

  local dependent_exts=()
  mapfile -t dependent_exts < <(check_dependent_extensions "go" "gofmt" "gopls")
  if [[ ${#dependent_exts[@]} -gt 0 ]]; then
    print_warning "The following extensions depend on Go and may stop working:"
    for ext in "${dependent_exts[@]}"; do
      echo "  - $ext"
    done
    echo ""
  fi

  if ! prompt_confirmation "Continue with Go removal?"; then
    print_status "Removal cancelled"
    return 1
  fi

  # Remove Go installation
  if [[ -d "/usr/local/go" ]]; then
    print_status "Removing Go installation..."
    sudo rm -rf /usr/local/go
    print_success "Go removed"
  else
    print_warning "Go installation directory not found"
  fi

  # Remove GOPATH
  if [[ -d "$HOME/go" ]]; then
    read -p "Remove $HOME/go directory? (y/N): " -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      rm -rf "$HOME/go"
      print_success "GOPATH directory removed"
    fi
  fi

  # Cleanup
  rm -f "/workspace/scripts/create-go-project.sh"
  cleanup_bashrc "# ${EXT_NAME}"
  command_exists git && git config --global --unset-all alias.gotest 2>/dev/null
  command_exists git && git config --global --unset-all alias.gofmt 2>/dev/null

  print_success "Go uninstalled"
  print_warning "Restart shell: source ~/.bashrc"
  return 0
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

extension_main "$@"
