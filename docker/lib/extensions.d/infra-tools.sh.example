#!/bin/bash
# infra-tools.sh.example - Infrastructure and DevOps tooling
# Extension API v1.0
#
# This extension installs infrastructure tools with:
# - IaC tools (Terraform, Pulumi, Crossplane)
# - Configuration management (Ansible)
# - Kubernetes tools (kubectl, Helm, k9s, kubectx/kubens)
# - Carvel suite (kapp, ytt, kbld, vendir, imgpkg)
# - Infrastructure workspace setup

# Source shared extension library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$(dirname "$SCRIPT_DIR")/extensions-common.sh"

# ============================================================================
# METADATA
# ============================================================================

EXT_NAME="infra-tools"
EXT_VERSION="1.0.0"
EXT_DESCRIPTION="Infrastructure and DevOps tooling (Terraform, Ansible, Kubernetes)"
EXT_CATEGORY="infrastructure"

# Initialize extension environment
extension_init

# ============================================================================
# PREREQUISITES
# ============================================================================

prerequisites() {
  print_status "Checking prerequisites for ${EXT_NAME}..."

  # Check for apt-get
  if ! command_exists apt-get; then
    print_error "apt-get is required but not found"
    print_status "This extension requires a Debian/Ubuntu based system"
    return 1
  fi

  # Check for required tools
  local missing_tools=()
  for tool in wget curl sudo git gpg lsb_release; do
    if ! command_exists "$tool"; then
      missing_tools+=("$tool")
    fi
  done

  if [[ ${#missing_tools[@]} -gt 0 ]]; then
    print_error "Missing required tools: ${missing_tools[*]}"
    print_status "Install with: sudo apt-get install wget curl sudo git gnupg lsb-release"
    return 1
  fi

  # Check disk space (infra tools need ~1.5GB)
  local available_space
  available_space=$(df -BM / | awk 'NR==2 {print $4}' | sed 's/M//')
  if [[ $available_space -lt 2000 ]]; then
    print_warning "Low disk space: ${available_space}MB available (2GB recommended for infrastructure tools)"
  fi

  print_success "All prerequisites met"
  return 0
}

# ============================================================================
# INSTALL
# ============================================================================

install() {
  print_status "Installing infrastructure tooling..."

  # Ansible
  print_status "Installing Ansible..."
  if command_exists ansible; then
    print_warning "Ansible already installed: $(ansible --version | head -1)"
  else
    sudo apt-get update -qq
    sudo apt-get install -y software-properties-common 2>/dev/null
    sudo add-apt-repository --yes --update ppa:ansible/ansible 2>/dev/null
    if sudo apt-get install -y ansible 2>/dev/null; then
      print_success "Ansible installed"
    else
      print_warning "Failed to install Ansible"
    fi
  fi

  # Terraform (via HashiCorp's official apt repository)
  print_status "Installing Terraform..."
  if command_exists terraform; then
    print_warning "Terraform already installed: $(terraform version | head -1)"
  else
    # Add HashiCorp GPG key
    if wget --timeout=60 --tries=2 -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg 2>/dev/null; then
      # Add HashiCorp repository
      echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | \
        sudo tee /etc/apt/sources.list.d/hashicorp.list > /dev/null

      # Update apt and install Terraform
      sudo apt-get update -qq 2>/dev/null
      if sudo apt-get install -y terraform 2>/dev/null; then
        print_success "Terraform installed (latest stable version)"
      else
        print_warning "Failed to install Terraform via apt"
      fi
    else
      print_warning "Failed to add HashiCorp repository"
    fi
  fi

  # kubectl
  print_status "Installing kubectl..."
  if command_exists kubectl; then
    print_warning "kubectl already installed"
  else
    local KUBECTL_VERSION
    KUBECTL_VERSION=$(curl --max-time 30 --retry 2 -L -s https://dl.k8s.io/release/stable.txt 2>/dev/null)
    if curl --max-time 120 --retry 2 -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" 2>/dev/null; then
      chmod +x kubectl
      sudo mv kubectl /usr/local/bin/
      print_success "kubectl installed"
    else
      print_warning "Failed to install kubectl"
    fi
  fi

  # Helm
  print_status "Installing Helm..."
  if command_exists helm; then
    # Use timeout for version check to avoid hanging
    local helm_version
    helm_version=$(timeout 3 bash -c 'helm version --short 2>&1' 2>/dev/null | head -n1 || echo "version unknown")
    print_warning "Helm already installed: ${helm_version}"
  else
    if curl --max-time 60 --retry 2 -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 2>/dev/null; then
      chmod 700 get_helm.sh
      # Run install script with timeout and check exit status
      if timeout 180 bash get_helm.sh 2>/dev/null; then
        rm -f get_helm.sh
        print_success "Helm installed"
      else
        rm -f get_helm.sh
        print_warning "Failed to install Helm (timeout or error)"
      fi
    else
      print_warning "Failed to download Helm installer"
    fi
  fi

  # Check if running in CI mode
  if [[ "$CI_MODE" == "true" ]]; then
    print_status "CI mode detected - skipping optional tools (Carvel, Crossplane, Pulumi, k9s, kubectx)"
    return 0
  fi

  # Carvel tools suite
  print_status "Installing Carvel tools..."
  local CARVEL_TOOLS=(kapp ytt kbld vendir imgpkg)
  local carvel_installed=0

  # Download Carvel install script once
  local carvel_script="/tmp/carvel-install.sh"
  if wget --timeout=90 -q -O "$carvel_script" "https://carvel.dev/install.sh"; then
    chmod +x "$carvel_script"

    for tool in "${CARVEL_TOOLS[@]}"; do
      if command_exists "$tool"; then
        print_debug "✓ $tool already installed"
        ((carvel_installed++))
      else
        print_debug "Installing $tool..."
        if timeout 120 bash "$carvel_script" "$tool" 2>&1 | grep -v "Installing linux-amd64 binaries"; then
          if [[ -f "./$tool" ]]; then
            sudo mv "./$tool" /usr/local/bin/ 2>/dev/null
          fi
          if command_exists "$tool"; then
            print_debug "✓ $tool installed"
            ((carvel_installed++))
          else
            print_warning "Failed to install $tool - binary not found after installation"
          fi
        else
          print_warning "Failed to install $tool - installation script failed"
        fi
      fi
    done

    rm -f "$carvel_script"
  else
    print_warning "Failed to download Carvel install script"
  fi

  print_status "Carvel tools: $carvel_installed/${#CARVEL_TOOLS[@]}"

  # Crossplane CLI
  print_status "Installing Crossplane CLI..."
  if command_exists crossplane; then
    print_warning "Crossplane CLI already installed"
  else
    if timeout 120 curl --max-time 90 -sL "https://raw.githubusercontent.com/crossplane/crossplane/master/install.sh" | sh 2>/dev/null; then
      sudo mv crossplane /usr/local/bin/ 2>/dev/null
      print_success "Crossplane CLI installed"
    else
      print_warning "Failed to install Crossplane CLI"
    fi
  fi

  # Pulumi
  print_status "Installing Pulumi..."
  if command_exists pulumi; then
    print_warning "Pulumi already installed: $(pulumi version)"
  else
    if timeout 180 curl --max-time 150 -fsSL https://get.pulumi.com | sh 2>/dev/null; then
      export PATH=$PATH:$HOME/.pulumi/bin
      print_success "Pulumi installed"
    else
      print_warning "Failed to install Pulumi"
    fi
  fi

  # k9s - Kubernetes TUI
  print_status "Installing k9s..."
  if command_exists k9s; then
    print_warning "k9s already installed"
  else
    local K9S_VERSION="v0.32.5"
    if wget --timeout=120 --tries=2 -q "https://github.com/derailed/k9s/releases/download/${K9S_VERSION}/k9s_Linux_amd64.tar.gz"; then
      tar xzf k9s_Linux_amd64.tar.gz k9s
      sudo mv k9s /usr/local/bin/
      rm k9s_Linux_amd64.tar.gz
      print_success "k9s installed"
    else
      print_warning "Failed to install k9s"
    fi
  fi

  # kubectx and kubens
  print_status "Installing kubectx/kubens..."
  if command_exists kubectx; then
    print_warning "kubectx/kubens already installed"
  else
    if timeout 60 sudo git clone --depth 1 https://github.com/ahmetb/kubectx /opt/kubectx 2>/dev/null; then
      sudo ln -s /opt/kubectx/kubectx /usr/local/bin/kubectx
      sudo ln -s /opt/kubectx/kubens /usr/local/bin/kubens
      print_success "kubectx/kubens installed"
    else
      print_warning "Failed to install kubectx/kubens"
    fi
  fi

  return 0
}

# ============================================================================
# CONFIGURE
# ============================================================================

configure() {
  print_status "Configuring infrastructure tools..."

  # Configure Pulumi PATH for SSH sessions
  if command_exists pulumi; then
    if command_exists setup_tool_path 2>/dev/null; then
      setup_tool_path "pulumi" 'export PATH=$PATH:$HOME/.pulumi/bin'
    else
      # Fallback: add to bashrc
      if ! grep -q ".pulumi/bin" "$HOME/.bashrc" 2>/dev/null; then
        echo "" >> "$HOME/.bashrc"
        echo "# ${EXT_NAME} - Pulumi" >> "$HOME/.bashrc"
        echo 'export PATH=$PATH:$HOME/.pulumi/bin' >> "$HOME/.bashrc"
        print_success "Added Pulumi to PATH"
      fi
    fi
    export PATH=$PATH:$HOME/.pulumi/bin
  fi

  # Create SSH wrappers
  if command_exists create_tool_wrapper 2>/dev/null; then
    local tools=(ansible terraform kubectl helm pulumi k9s kubectx kubens crossplane)
    local carvel_tools=(kapp ytt kbld vendir imgpkg)
    tools+=("${carvel_tools[@]}")

    for tool in "${tools[@]}"; do
      if command_exists "$tool"; then
        create_tool_wrapper "$tool" "$(which $tool)"
      fi
    done
  fi

  # Create infrastructure aliases
  if ! grep -q "# Infrastructure aliases" "$HOME/.bashrc" 2>/dev/null; then
    print_status "Creating infrastructure aliases..."
    cat >> "$HOME/.bashrc" << 'EOF'

# Infrastructure aliases
alias tf="terraform"
alias tfi="terraform init"
alias tfp="terraform plan"
alias tfa="terraform apply"
alias tfd="terraform destroy"
alias tfv="terraform validate"
alias tff="terraform fmt"

# Kubernetes aliases
alias k="kubectl"
alias kg="kubectl get"
alias kd="kubectl describe"
alias kdel="kubectl delete"
alias kl="kubectl logs"
alias kx="kubectx"
alias kn="kubens"

# Helm aliases
alias h="helm"
alias hi="helm install"
alias hu="helm upgrade"
alias hls="helm list"
alias hdel="helm delete"
alias hs="helm search"

# Ansible aliases
alias ap="ansible-playbook"
alias av="ansible-vault"
alias ag="ansible-galaxy"

# Pulumi aliases
alias pu="pulumi"
alias pup="pulumi up"
alias pud="pulumi destroy"
alias pus="pulumi stack"

# Carvel aliases
alias ka="kapp"
alias kad="kapp deploy"
alias kal="kapp list"
alias kadel="kapp delete"
EOF
    print_success "Infrastructure aliases created"
  else
    print_debug "Infrastructure aliases already exist"
  fi

  # Create infrastructure workspace
  local WORKSPACE_DIR="${WORKSPACE_DIR:-/workspace}"
  print_status "Setting up infrastructure workspace..."
  mkdir -p "$WORKSPACE_DIR/infrastructure"/{terraform,kubernetes,helm-charts,crossplane,pulumi}

  # Create README guide
  if [[ ! -f "$WORKSPACE_DIR/infrastructure/README.md" ]]; then
    cat > "$WORKSPACE_DIR/infrastructure/README.md" << 'EOF'
# Infrastructure as Code Workspace

## Available Tools

### Core IaC Tools
- **Terraform**: Infrastructure provisioning and management
- **Pulumi**: Infrastructure as code using general-purpose languages
- **Crossplane**: Kubernetes-native infrastructure management

### Kubernetes Tools
- **kubectl**: Kubernetes command-line tool
- **Helm**: Kubernetes package manager
- **k9s**: Terminal UI for Kubernetes clusters
- **kubectx/kubens**: Context and namespace switching

### Carvel Suite
- **kapp**: Deploy and view groups of Kubernetes resources
- **ytt**: Template and overlay Kubernetes configuration
- **kbld**: Build or reference container images in Kubernetes configuration
- **vendir**: Declaratively state directory contents
- **imgpkg**: Bundle and relocate application configuration and images

## Directory Structure
```
infrastructure/
├── terraform/     # Terraform configurations
├── kubernetes/    # Raw Kubernetes manifests
├── helm-charts/   # Helm charts
├── crossplane/    # Crossplane compositions
└── pulumi/        # Pulumi projects
```

## Quick Start

### Terraform
```bash
cd terraform/
terraform init
terraform plan
terraform apply
```

### Kubernetes
```bash
kubectl config get-contexts
kubectl apply -f kubernetes/
```

### Helm
```bash
helm repo add stable https://charts.helm.sh/stable
helm search repo stable
helm install myapp ./helm-charts/myapp
```

### Carvel
```bash
# Deploy with kapp
kapp deploy -a myapp -f kubernetes/

# Template with ytt
ytt -f config/ --data-values-file values.yaml

# Bundle with imgpkg
imgpkg push -b registry.example.com/my-bundle:v1.0.0 -f config/
```
EOF
    print_success "Infrastructure README created"
  fi

  print_success "Infrastructure tools configured"
  return 0
}

# ============================================================================
# VALIDATE
# ============================================================================

validate() {
  print_status "Validating infrastructure tools installation..."

  local all_valid=true

  # Core tools
  local core_tools=(ansible terraform kubectl helm)
  for tool in "${core_tools[@]}"; do
    if ! command_exists "$tool"; then
      print_error "$tool not found"
      all_valid=false
    else
      print_success "$tool: installed"
    fi
  done

  # Optional tools
  local optional_tools=(pulumi crossplane k9s kubectx)
  local optional_found=0
  for tool in "${optional_tools[@]}"; do
    command_exists "$tool" && ((optional_found++))
  done
  print_status "Optional tools: $optional_found/${#optional_tools[@]}"

  # Carvel tools
  local carvel_tools=(kapp ytt kbld vendir imgpkg)
  local carvel_found=0
  for tool in "${carvel_tools[@]}"; do
    command_exists "$tool" && ((carvel_found++))
  done
  print_status "Carvel tools: $carvel_found/${#carvel_tools[@]}"

  # Check workspace
  local WORKSPACE_DIR="${WORKSPACE_DIR:-/workspace}"
  if [[ -d "$WORKSPACE_DIR/infrastructure" ]]; then
    print_success "Infrastructure workspace: exists"
  else
    print_warning "Infrastructure workspace: not found"
  fi

  if [[ "$all_valid" == "true" ]]; then
    print_success "Validation passed"
    return 0
  else
    print_error "Validation failed"
    return 1
  fi
}

# ============================================================================
# STATUS
# ============================================================================

status() {
  print_status "Checking infrastructure tools status..."

  # Core tools
  print_status "Core tools:"
  local core_tools=(ansible terraform kubectl helm)
  for tool in "${core_tools[@]}"; do
    if command_exists "$tool"; then
      local version=""
      case "$tool" in
        ansible) version=$(ansible --version | head -1) ;;
        terraform) version=$(terraform version | head -1) ;;
        kubectl) version=$(kubectl version --client --short 2>/dev/null | head -1) ;;
        helm) version=$(helm version --short) ;;
      esac
      echo "  ✓ $tool: $version"
    fi
  done

  # Optional tools
  print_status "Optional tools:"
  local optional_tools=(pulumi crossplane k9s kubectx kubens)
  for tool in "${optional_tools[@]}"; do
    command_exists "$tool" && echo "  ✓ $tool"
  done

  # Carvel tools
  print_status "Carvel tools:"
  local carvel_tools=(kapp ytt kbld vendir imgpkg)
  for tool in "${carvel_tools[@]}"; do
    command_exists "$tool" && echo "  ✓ $tool"
  done

  # Workspace
  local WORKSPACE_DIR="${WORKSPACE_DIR:-/workspace}"
  if [[ -d "$WORKSPACE_DIR/infrastructure" ]]; then
    print_status "Infrastructure workspace:"
    echo "  $WORKSPACE_DIR/infrastructure/"
    for dir in terraform kubernetes helm-charts crossplane pulumi; do
      [[ -d "$WORKSPACE_DIR/infrastructure/$dir" ]] && echo "    ├── $dir/"
    done
  fi

  return 0
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

check_dependent_extensions() {
  local provided_commands=("$@")
  local dependent_extensions=()
  local manifest_file="$SCRIPT_DIR/active-extensions.conf"
  [[ ! -f "$manifest_file" ]] && manifest_file="/workspace/scripts/extensions.d/active-extensions.conf"
  [[ ! -f "$manifest_file" ]] && return 0

  while IFS= read -r line; do
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ -z "${line// }" ]] && continue
    local ext_name=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    [[ "$ext_name" == "$EXT_NAME" ]] && continue
    local ext_file="$SCRIPT_DIR/${ext_name}.sh"
    if [[ ! -f "$ext_file" ]]; then
      local matches=("$SCRIPT_DIR/"*"-${ext_name}.sh")
      ext_file="${matches[0]}"
    fi
    [[ ! -f "$ext_file" ]] && continue
    for cmd in "${provided_commands[@]}"; do
      if grep -q "$cmd" "$ext_file" 2>/dev/null; then
        dependent_extensions+=("$ext_name")
        break
      fi
    done
  done < "$manifest_file"

  printf '%s\n' "${dependent_extensions[@]}"
}

# ============================================================================
# REMOVE
# ============================================================================

remove() {
  print_warning "Uninstalling infrastructure tools..."

  local dependent_exts=()
  mapfile -t dependent_exts < <(check_dependent_extensions "terraform" "kubectl" "helm" "ansible" "pulumi")
  if [[ ${#dependent_exts[@]} -gt 0 ]]; then
    print_warning "The following extensions depend on infrastructure tools and may stop working:"
    for ext in "${dependent_exts[@]}"; do
      echo "  - $ext"
    done
    echo ""
  fi

  if ! prompt_confirmation "Continue with infrastructure tools removal?"; then
    print_status "Removal cancelled"
    return 1
  fi

  # Remove Ansible
  print_status "Removing Ansible..."
  sudo apt-get remove -y ansible 2>/dev/null
  sudo add-apt-repository --remove --yes ppa:ansible/ansible 2>/dev/null

  # Remove Terraform
  print_status "Removing Terraform..."
  if dpkg -l | grep -q terraform; then
    # Installed via apt
    sudo apt-get remove -y terraform 2>/dev/null
    sudo rm -f /etc/apt/sources.list.d/hashicorp.list
    sudo rm -f /usr/share/keyrings/hashicorp-archive-keyring.gpg
  else
    # Legacy binary installation
    [[ -f /usr/local/bin/terraform ]] && sudo rm -f /usr/local/bin/terraform
  fi

  # Remove kubectl
  [[ -f /usr/local/bin/kubectl ]] && sudo rm -f /usr/local/bin/kubectl

  # Remove Helm
  [[ -f /usr/local/bin/helm ]] && sudo rm -f /usr/local/bin/helm

  # Remove Carvel tools
  local carvel_tools=(kapp ytt kbld vendir imgpkg)
  for tool in "${carvel_tools[@]}"; do
    [[ -f /usr/local/bin/$tool ]] && sudo rm -f /usr/local/bin/$tool
  done

  # Remove Crossplane
  [[ -f /usr/local/bin/crossplane ]] && sudo rm -f /usr/local/bin/crossplane

  # Remove Pulumi
  if [[ -d "$HOME/.pulumi" ]]; then
    read -p "Remove Pulumi installation directory? (y/N): " -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      rm -rf "$HOME/.pulumi"
      print_success "Pulumi removed"
    fi
  fi

  # Remove k9s
  [[ -f /usr/local/bin/k9s ]] && sudo rm -f /usr/local/bin/k9s

  # Remove kubectx/kubens
  if [[ -d /opt/kubectx ]]; then
    sudo rm -f /usr/local/bin/kubectx /usr/local/bin/kubens
    sudo rm -rf /opt/kubectx
    print_success "kubectx/kubens removed"
  fi

  # Remove aliases
  cleanup_bashrc "# Infrastructure aliases"

  # Remove Pulumi PATH from bashrc
  cleanup_bashrc "# ${EXT_NAME}"

  # Remove workspace
  local WORKSPACE_DIR="${WORKSPACE_DIR:-/workspace}"
  if [[ -d "$WORKSPACE_DIR/infrastructure" ]]; then
    read -p "Remove infrastructure workspace directory? (y/N): " -r
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      rm -rf "$WORKSPACE_DIR/infrastructure"
      print_success "Infrastructure workspace removed"
    fi
  fi

  print_success "Infrastructure tools uninstalled"
  print_warning "Restart shell: source ~/.bashrc"
  return 0
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

extension_main "$@"
