#!/bin/bash
# template.sh.example - Extension Template and Reference Implementation
# Extension API v1.0
#
# This template demonstrates the standard extension structure with all required
# functions. Use this as a reference when creating new extensions.
#
# IMPORTANT: Copy this template and rename to match your extension (e.g., rust.sh.example)

# ============================================================================
# METADATA
# ============================================================================
# Simple variables - no functions needed
# Note: Priority/order is defined in /workspace/config/active-extensions.conf

EXT_NAME="template"
EXT_VERSION="1.0.0"
EXT_DESCRIPTION="Extension template and reference implementation"
EXT_CATEGORY="dev-tools"

# ============================================================================
# COMMON UTILITIES
# ============================================================================
# Source common functions from lib/common.sh
# This provides: print_status, print_success, print_error, print_warning, print_debug, command_exists

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$(dirname "$SCRIPT_DIR")"

if [[ -f "$LIB_DIR/common.sh" ]]; then
  source "$LIB_DIR/common.sh"
elif [[ -f "/workspace/scripts/lib/common.sh" ]]; then
  source "/workspace/scripts/lib/common.sh"
else
  # Minimal fallback if common.sh not found
  print_status() { echo "[INFO] $1"; }
  print_success() { echo "[SUCCESS] $1"; }
  print_error() { echo "[ERROR] $1" >&2; }
  print_warning() { echo "[WARNING] $1"; }
  print_debug() { [[ "${DEBUG:-}" == "true" ]] && echo "[DEBUG] $1"; }
  command_exists() { command -v "$1" >/dev/null 2>&1; }
fi

# ============================================================================
# FUNCTION 1: PREREQUISITES
# ============================================================================
# Check if all requirements are met before installation
# Returns: 0 if all prerequisites met, 1 otherwise
#
# Common checks:
# - System packages (build-essential, curl, etc.)
# - Commands available in PATH
# - Disk space
# - Memory
# - Network connectivity
# - Other extensions (dependencies)
#
# Example usage:
#   if prerequisites; then
#     echo "Prerequisites met"
#   else
#     echo "Prerequisites not met"
#     exit 1
#   fi

prerequisites() {
  print_status "Checking prerequisites for ${EXT_NAME}..."

  local all_met=true

  # Example: Check for required system packages
  local required_packages=("curl" "wget" "git")
  for pkg in "${required_packages[@]}"; do
    if ! command_exists "$pkg"; then
      print_error "Required command not found: $pkg"
      all_met=false
    fi
  done

  # Example: Check for required commands
  if ! command_exists gcc; then
    print_warning "GCC not found - install build-essential"
    all_met=false
  fi

  # Example: Check disk space (optional)
  local available_space
  available_space=$(df -BG /workspace | awk 'NR==2 {print $4}' | sed 's/G//')
  if [[ $available_space -lt 5 ]]; then
    print_warning "Low disk space: ${available_space}GB available (5GB recommended)"
  fi

  # Example: Respect CI_MODE for conditional checks
  if [[ "${CI_MODE:-}" != "true" ]]; then
    print_debug "Running in normal mode (not CI)"
  fi

  if [[ "$all_met" == "true" ]]; then
    print_success "All prerequisites met"
    return 0
  else
    print_error "Prerequisites not met"
    return 1
  fi
}

# ============================================================================
# FUNCTION 2: INSTALL
# ============================================================================
# Install packages, tools, and binaries
# Returns: 0 on success, 1 on failure
#
# Common patterns:
# - apt-get install (system packages)
# - Download binaries (curl/wget)
# - Language package managers (npm, pip, cargo, gem, etc.)
# - Build from source
#
# Best practices:
# - Check if already installed before installing
# - Respect CI_MODE for minimal installation
# - Use timeouts for long-running operations
# - Provide progress feedback
# - Handle errors gracefully
#
# Example usage:
#   if install; then
#     echo "Installation successful"
#   else
#     echo "Installation failed"
#     exit 1
#   fi

install() {
  print_status "Installing ${EXT_NAME}..."

  # Example: Check if already installed
  if command_exists example-tool; then
    print_warning "Tool already installed: $(example-tool --version)"
    return 0
  fi

  # Example: Install system packages
  print_status "Installing system dependencies..."
  if ! sudo apt-get update -qq; then
    print_error "Failed to update package lists"
    return 1
  fi

  if ! sudo apt-get install -y example-package; then
    print_error "Failed to install example-package"
    return 1
  fi

  # Example: Download and install binary
  print_status "Downloading example-tool..."
  local download_url="https://example.com/tool.tar.gz"
  local temp_file="/tmp/example-tool.tar.gz"

  if ! curl -fsSL "$download_url" -o "$temp_file"; then
    print_error "Failed to download from $download_url"
    return 1
  fi

  # Example: Extract and install
  if ! tar -xzf "$temp_file" -C /usr/local/bin/; then
    print_error "Failed to extract archive"
    rm -f "$temp_file"
    return 1
  fi

  rm -f "$temp_file"

  # Example: CI_MODE optimization - skip optional tools
  if [[ "${CI_MODE:-}" != "true" ]]; then
    print_status "Installing optional tools..."
    # Install additional tools here
  else
    print_debug "CI mode - skipping optional tools"
  fi

  print_success "${EXT_NAME} installed successfully"
  return 0
}

# ============================================================================
# FUNCTION 3: CONFIGURE
# ============================================================================
# Post-installation configuration
# Returns: 0 on success, 1 on failure
#
# Common tasks:
# - Add to PATH
# - Create SSH wrappers (for non-interactive sessions)
# - Setup shell aliases
# - Create configuration files
# - Initialize user settings
# - Setup environment variables
#
# Best practices:
# - Make idempotent (can run multiple times safely)
# - Check before modifying shell config files
# - Use symlinks where appropriate
# - Set proper file permissions
#
# Example usage:
#   if configure; then
#     echo "Configuration successful"
#   else
#     echo "Configuration failed"
#     exit 1
#   fi

configure() {
  print_status "Configuring ${EXT_NAME}..."

  # Example: Add to PATH
  local bin_path="/opt/example-tool/bin"
  if [[ -d "$bin_path" ]]; then
    if ! grep -q "$bin_path" "$HOME/.bashrc" 2>/dev/null; then
      echo "" >> "$HOME/.bashrc"
      echo "# ${EXT_NAME} - added by extension" >> "$HOME/.bashrc"
      echo "export PATH=\"$bin_path:\$PATH\"" >> "$HOME/.bashrc"
      print_success "Added $bin_path to PATH"
    else
      print_debug "PATH already contains $bin_path"
    fi
  fi

  # Example: Create SSH wrapper for non-interactive sessions
  # This ensures commands work in CI and non-interactive SSH
  if command_exists example-tool; then
    setup_tool_path "${EXT_NAME}" \
      "export PATH=\"$bin_path:\$PATH\"" \
      "source /opt/example-tool/env"

    create_tool_wrapper "example-tool" "$bin_path/example-tool"
  fi

  # Example: Setup shell aliases
  if ! grep -q "alias example-run" "$HOME/.bashrc" 2>/dev/null; then
    echo "alias example-run='example-tool run'" >> "$HOME/.bashrc"
  fi

  # Example: Create config file
  local config_dir="$HOME/.config/example-tool"
  local config_file="$config_dir/config.yaml"

  if [[ ! -f "$config_file" ]]; then
    mkdir -p "$config_dir"
    cat > "$config_file" << 'EOF'
# Example tool configuration
setting1: value1
setting2: value2
EOF
    chmod 644 "$config_file"
    print_success "Created config file: $config_file"
  fi

  print_success "${EXT_NAME} configured successfully"
  return 0
}

# ============================================================================
# FUNCTION 4: VALIDATE
# ============================================================================
# Smoke tests to verify installation and configuration
# Returns: 0 if all validations pass, 1 otherwise
#
# Common validations:
# - Command availability (command -v)
# - Version checks
# - Functional tests (can it actually run?)
# - Configuration file existence
# - SSH wrapper tests (for non-interactive sessions)
#
# Best practices:
# - Test actual functionality, not just presence
# - Use timeouts for operations that might hang
# - Provide clear error messages
# - Respect CI_MODE for faster validation
#
# Example usage:
#   if validate; then
#     echo "Validation passed"
#   else
#     echo "Validation failed"
#     exit 1
#   fi

validate() {
  print_status "Validating ${EXT_NAME} installation..."

  local all_valid=true

  # Example: Check command exists
  if ! command_exists example-tool; then
    print_error "example-tool command not found in PATH"
    all_valid=false
  else
    print_success "example-tool command found"

    # Example: Check version
    local version
    if version=$(example-tool --version 2>/dev/null); then
      print_success "example-tool version: $version"
    else
      print_error "Failed to get example-tool version"
      all_valid=false
    fi
  fi

  # Example: Functional test
  print_status "Running functional test..."
  if example-tool test >/dev/null 2>&1; then
    print_success "Functional test passed"
  else
    print_error "Functional test failed"
    all_valid=false
  fi

  # Example: Check configuration
  if [[ -f "$HOME/.config/example-tool/config.yaml" ]]; then
    print_success "Configuration file exists"
  else
    print_warning "Configuration file not found (optional)"
  fi

  # Example: Test SSH wrapper (critical for CI)
  if [[ "${CI_MODE:-}" != "true" ]]; then
    print_status "Testing non-interactive SSH execution..."
    if ssh localhost "example-tool --version" >/dev/null 2>&1; then
      print_success "SSH wrapper works"
    else
      print_warning "SSH wrapper test failed (may not be critical)"
    fi
  fi

  if [[ "$all_valid" == "true" ]]; then
    print_success "Validation passed"
    return 0
  else
    print_error "Validation failed"
    return 1
  fi
}

# ============================================================================
# FUNCTION 5: STATUS
# ============================================================================
# Check current installation status
# Returns: 0 if installed, 1 if not installed
#
# Purpose:
# - Quick check if extension is currently installed
# - Show versions of installed tools
# - Display configuration status
# - Provide usage information
#
# Best practices:
# - Be fast (this may be called frequently)
# - Provide useful summary information
# - Use print_status/print_success for output
#
# Example usage:
#   if status; then
#     echo "Extension is installed"
#   else
#     echo "Extension is not installed"
#   fi

status() {
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo "Extension: $EXT_NAME v$EXT_VERSION"
  echo "Description: $EXT_DESCRIPTION"
  echo "Category: $EXT_CATEGORY"
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""

  # Check installation status
  if ! command_exists example-tool; then
    echo "Status: ✗ NOT INSTALLED"
    return 1
  fi

  echo "Status: ✓ INSTALLED"
  echo ""

  # Extension-specific tool listing with versions
  print_status "Installed tools:"
  local version
  if version=$(example-tool --version 2>/dev/null); then
    echo "  ✓ example-tool: $version"
  else
    echo "  ✓ example-tool: installed (version check failed)"
  fi

  # Show configuration status
  echo ""
  print_status "Configuration:"
  if [[ -f "$HOME/.config/example-tool/config.yaml" ]]; then
    echo "  ✓ $HOME/.config/example-tool/config.yaml"
  else
    echo "  ✗ No configuration found"
  fi

  # Show PATH status
  echo ""
  if echo "$PATH" | grep -q "/opt/example-tool/bin"; then
    print_status "PATH configured: ✓"
  else
    print_status "PATH configured: ✗ (restart shell)"
  fi

  return 0
}

# ============================================================================
# FUNCTION 6: REMOVE
# ============================================================================
# Uninstall packages and clean up configuration
# Returns: 0 on success, 1 on failure
#
# Common tasks:
# - Remove installed packages
# - Delete binaries
# - Clean up configuration files
# - Remove PATH modifications
# - Delete SSH wrappers
# - Clean cache/temporary files
#
# Best practices:
# - Prompt for confirmation on destructive operations
# - Provide option to keep user data/config
# - Clean up in reverse order of installation
# - Handle partial installations gracefully
# - Remove entries from shell config files
#
# Example usage:
#   if remove; then
#     echo "Removal successful"
#   else
#     echo "Removal failed"
#     exit 1
#   fi

remove() {
  print_status "Removing ${EXT_NAME}..."

  # Example: Remove system packages
  if command_exists example-package; then
    print_status "Removing system packages..."
    if sudo apt-get remove -y example-package; then
      print_success "System packages removed"
    else
      print_warning "Failed to remove some system packages"
    fi
  fi

  # Example: Remove binary
  if [[ -f "/usr/local/bin/example-tool" ]]; then
    print_status "Removing binary..."
    if sudo rm -f "/usr/local/bin/example-tool"; then
      print_success "Binary removed"
    else
      print_error "Failed to remove binary"
      return 1
    fi
  fi

  # Example: Clean up configuration (with warning)
  local config_dir="$HOME/.config/example-tool"
  if [[ -d "$config_dir" ]]; then
    print_warning "Configuration directory exists: $config_dir"
    print_status "Remove config? This will delete user settings."
    read -p "Delete $config_dir? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      rm -rf "$config_dir"
      print_success "Configuration removed"
    else
      print_status "Configuration preserved"
    fi
  fi

  # Example: Remove from PATH (bashrc)
  if grep -q "# ${EXT_NAME} - added by extension" "$HOME/.bashrc" 2>/dev/null; then
    print_status "Removing PATH modifications..."
    cleanup_bashrc "# ${EXT_NAME} - added by extension"
    print_success "PATH modifications removed"
  fi

  # Example: Remove SSH wrappers
  if [[ -f "/usr/local/bin/example-tool" ]]; then
    sudo rm -f "/usr/local/bin/example-tool"
    print_debug "SSH wrapper removed"
  fi

  # Example: Clean cache
  if [[ -d "$HOME/.cache/example-tool" ]]; then
    rm -rf "$HOME/.cache/example-tool"
    print_debug "Cache cleaned"
  fi

  print_success "${EXT_NAME} removed successfully"
  print_warning "Restart your shell or run: source ~/.bashrc"
  return 0
}

# ============================================================================
# MAIN EXECUTION (for testing)
# ============================================================================
# This allows testing the extension directly
# Usage: ./template.sh.example [prerequisites|install|configure|validate|status|remove]

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # Script is being executed directly
  command="${1:-status}"

  case "$command" in
    prerequisites|install|configure|validate|status|remove)
      if "$command"; then
        exit 0
      else
        exit 1
      fi
      ;;
    *)
      echo "Usage: $0 {prerequisites|install|configure|validate|status|remove}"
      exit 1
      ;;
  esac
fi
