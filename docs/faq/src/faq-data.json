{
  "categories": [
    {
      "id": "getting-started",
      "name": "Getting Started",
      "icon": "rocket",
      "description": "Setup, prerequisites, and first steps"
    },
    {
      "id": "configuration",
      "name": "Configuration",
      "icon": "cog",
      "description": "sindri.yaml, profiles, and settings"
    },
    {
      "id": "deployment",
      "name": "Deployment",
      "icon": "cloud",
      "description": "Docker, Fly.io, DevPod, and Kubernetes"
    },
    {
      "id": "extensions",
      "name": "Extensions",
      "icon": "puzzle",
      "description": "Installing, managing, and creating extensions"
    },
    {
      "id": "secrets",
      "name": "Secrets Management",
      "icon": "key",
      "description": "Environment variables, Vault, and files"
    },
    {
      "id": "troubleshooting",
      "name": "Troubleshooting",
      "icon": "wrench",
      "description": "Common errors and debugging"
    },
    {
      "id": "architecture",
      "name": "Architecture",
      "icon": "layers",
      "description": "How Sindri works under the hood"
    },
    {
      "id": "cicd",
      "name": "CI/CD & Automation",
      "icon": "refresh",
      "description": "GitHub Actions and automation"
    }
  ],
  "questions": [
    {
      "id": "what-is-sindri",
      "category": "getting-started",
      "question": "What is Sindri?",
      "answer": "Sindri is a declarative, provider-agnostic cloud development environment system. It uses YAML-defined extensions and optimized Docker images to deploy consistent development environments to Fly.io, local Docker, or via DevPod to Kubernetes, AWS, GCP, Azure, and other cloud providers. The core design principles are YAML-first architecture, provider agnosticism, immutable/mutable split for system files, and fast startup times.",
      "tags": ["overview", "introduction", "basics"],
      "docs": ["README.md", "docs/ARCHITECTURE.md"]
    },
    {
      "id": "prerequisites",
      "category": "getting-started",
      "question": "What are the prerequisites for using Sindri?",
      "answer": "The core prerequisites are: Docker installed, yq installed (brew install yq on macOS or download from GitHub). For Fly.io deployments, you need flyctl installed. For DevPod deployments, you need the DevPod CLI installed. Optional tools include pnpm for running validation and tests.",
      "tags": ["setup", "requirements", "installation"],
      "docs": ["docs/QUICKSTART.md"]
    },
    {
      "id": "quick-start",
      "category": "getting-started",
      "question": "How do I get started with Sindri quickly?",
      "answer": "Clone the repository (git clone https://github.com/pacphi/sindri), make the CLI executable (chmod +x cli/sindri), initialize configuration (sindri config init), edit sindri.yaml to your needs, then deploy with 'sindri deploy'. For local development, use '--provider docker'. The whole process takes less than 5 minutes.",
      "tags": ["quickstart", "tutorial", "beginner"],
      "docs": ["docs/QUICKSTART.md"]
    },
    {
      "id": "first-deploy",
      "category": "getting-started",
      "question": "What happens during my first deployment?",
      "answer": "During first deployment, Sindri validates your configuration, builds or pulls the Docker image, deploys using the provider-specific adapter (Docker Compose, flyctl, or devpod), initializes the persistent volume with the home directory structure, sets up SSH authorized keys, configures Git user settings, and starts the SSH daemon (unless in CI mode). The environment is then ready for use.",
      "tags": ["deploy", "first-time", "initialization"],
      "docs": ["docs/DEPLOYMENT.md"]
    },
    {
      "id": "supported-providers",
      "category": "getting-started",
      "question": "Which cloud providers does Sindri support?",
      "answer": "Sindri supports three primary deployment providers: Docker (local development), Fly.io (cloud with auto-suspend), and DevPod (IDE-integrated). DevPod is a meta-provider that supports multiple backends including local Docker, AWS EC2, GCP Compute, Azure VMs, DigitalOcean Droplets, Kubernetes pods, and any SSH host. This makes Sindri truly provider-agnostic.",
      "tags": ["providers", "cloud", "deployment"],
      "docs": ["docs/DEPLOYMENT.md", "docs/providers/"]
    },
    {
      "id": "config-init",
      "category": "configuration",
      "question": "How do I create a sindri.yaml configuration file?",
      "answer": "Run 'sindri config init' to generate a template sindri.yaml with sensible defaults. This creates a file with version, name, deployment settings (provider, resources, volumes), extensions configuration, and provider-specific options. You can then customize it for your needs. Always validate with 'sindri config validate' after making changes.",
      "tags": ["config", "yaml", "setup"],
      "docs": ["docs/CONFIGURATION.md", "docs/CLI.md"]
    },
    {
      "id": "config-validation",
      "category": "configuration",
      "question": "How do I validate my sindri.yaml configuration?",
      "answer": "Run 'sindri config validate' to validate your configuration against the JSON schema. This checks for required fields, correct types, valid provider names, and proper structure. The schema is located at docker/lib/schemas/sindri.schema.json. Exit code 0 means valid, exit code 1 means validation failed with errors displayed.",
      "tags": ["validation", "schema", "config"],
      "docs": ["docs/CONFIGURATION.md", "docs/SCHEMA.md"]
    },
    {
      "id": "profiles-vs-extensions",
      "category": "configuration",
      "question": "What's the difference between profiles and individual extensions?",
      "answer": "Profiles are pre-configured bundles of extensions for common workflows (e.g., 'fullstack' includes nodejs, python, docker, nodejs-devtools). Individual extensions let you pick exactly what you need. You can use a profile as a base and add additional extensions on top. In sindri.yaml, use 'extensions.profile' for a bundle or 'extensions.active' for individual selections.",
      "tags": ["profiles", "extensions", "bundles"],
      "docs": ["docs/EXTENSIONS.md", "docs/CONFIGURATION.md"]
    },
    {
      "id": "available-profiles",
      "category": "configuration",
      "question": "What extension profiles are available?",
      "answer": "Available profiles include: minimal (nodejs, python), fullstack (nodejs, python, docker, nodejs-devtools), ai-dev (nodejs, python, ai-toolkit, openskills, monitoring), anthropic-dev (comprehensive Claude/AI toolset), systems (rust, golang, docker, infra-tools), enterprise (all languages and infrastructure), data-science (python, monitoring), devops (docker, infra-tools, cloud-tools, monitoring), and mobile (nodejs).",
      "tags": ["profiles", "list", "options"],
      "docs": ["docs/EXTENSIONS.md", "docker/lib/profiles.yaml"]
    },
    {
      "id": "resource-allocation",
      "category": "configuration",
      "question": "How do I configure memory and CPU resources?",
      "answer": "In sindri.yaml, set deployment.resources.memory (e.g., '2GB', '4GB') and deployment.resources.cpus (e.g., 1, 2). For Fly.io, memory tiers map to specific VM sizes: 1GB (~$5-10/mo), 2GB (~$10-15/mo), 4GB (~$30-40/mo). You can also set cpuKind to 'shared' (cheaper) or 'performance' (dedicated CPU) for Fly.io.",
      "tags": ["resources", "memory", "cpu", "sizing"],
      "docs": ["docs/CONFIGURATION.md"]
    },
    {
      "id": "volume-size",
      "category": "configuration",
      "question": "How do I configure persistent volume size?",
      "answer": "Set deployment.volumes.workspace.size in sindri.yaml (e.g., '10GB', '30GB', '100GB'). This is the persistent storage for your home directory, workspace, and installed tools. For Fly.io, costs are approximately $1.50/month for 10GB, $4.50/month for 30GB, and $15/month for 100GB. The volume persists across container restarts.",
      "tags": ["volumes", "storage", "persistence"],
      "docs": ["docs/CONFIGURATION.md"]
    },
    {
      "id": "deploy-idempotent",
      "category": "deployment",
      "question": "Is 'sindri deploy' idempotent? Can I re-run it after making changes?",
      "answer": "Yes, sindri deploy is designed to be re-runnable. Fly.io is most idempotent (~95%) with explicit checks for existing resources. Docker relies on docker-compose idempotency (~70%). DevPod delegates to its CLI (~60%). You can edit sindri.yaml and re-deploy to apply configuration changes like memory, CPU, or profile. Use '--skip-build' for faster iteration when you don't need image rebuilds.",
      "tags": ["idempotent", "redeploy", "update", "changes"],
      "docs": ["docs/DEPLOYMENT.md"]
    },
    {
      "id": "deploy-docker",
      "category": "deployment",
      "question": "How do I deploy to local Docker?",
      "answer": "Run 'sindri deploy --provider docker' or set 'deployment.provider: docker' in sindri.yaml. This generates a docker-compose.yml and runs 'docker compose up -d'. Connect with 'sindri connect' or 'docker exec'. Docker is ideal for local development, testing, offline work, and zero-cost environments.",
      "tags": ["docker", "local", "compose"],
      "docs": ["docs/providers/DOCKER.md"]
    },
    {
      "id": "deploy-fly",
      "category": "deployment",
      "question": "How do I deploy to Fly.io?",
      "answer": "First authenticate with 'flyctl auth login'. Then run 'sindri deploy --provider fly' or set 'deployment.provider: fly' in sindri.yaml. Configure region, organization, SSH port, and auto-suspend options under providers.fly. Fly.io is great for remote access, cost-optimized cloud deployment, and auto-suspend/resume capabilities.",
      "tags": ["fly", "flyio", "cloud"],
      "docs": ["docs/providers/FLY.md"]
    },
    {
      "id": "deploy-devpod",
      "category": "deployment",
      "question": "How do I deploy with DevPod?",
      "answer": "Run 'sindri deploy --provider devpod' to generate a devcontainer.json. DevPod supports multiple backends via the 'type' field: docker (local), aws, gcp, azure, digitalocean, kubernetes, or ssh. For VS Code integration, open the folder and use 'Dev Containers: Open Folder in Container'. DevPod is ideal for IDE integration and multi-cloud deployments.",
      "tags": ["devpod", "devcontainer", "vscode"],
      "docs": ["docs/providers/DEVPOD.md"]
    },
    {
      "id": "deploy-kubernetes",
      "category": "deployment",
      "question": "How do I deploy to Kubernetes?",
      "answer": "Kubernetes deployment uses DevPod with 'type: kubernetes'. Set 'deployment.provider: devpod' and configure 'providers.devpod.type: kubernetes' with namespace and storageClass options. For local K8s testing, Sindri can auto-provision kind or k3d clusters. For remote clusters, provide KUBECONFIG or use the context option.",
      "tags": ["kubernetes", "k8s", "pods"],
      "docs": ["docs/providers/KUBERNETES.md"]
    },
    {
      "id": "fly-auto-suspend",
      "category": "deployment",
      "question": "How does Fly.io auto-suspend work? Will I save money?",
      "answer": "Enable auto-suspend with 'providers.fly.autoStopMachines: true' and 'autoStartMachines: true'. The machine suspends after ~5 minutes of idle time and automatically resumes when you SSH connect. You only pay for active time, not idle time, which can significantly reduce costs for intermittent development work.",
      "tags": ["fly", "autosuspend", "cost", "billing"],
      "docs": ["docs/providers/FLY.md", "docs/CONFIGURATION.md"]
    },
    {
      "id": "connect-environment",
      "category": "deployment",
      "question": "How do I connect to my deployed environment?",
      "answer": "Run 'sindri connect' which auto-detects the provider and opens an SSH session. For Docker, it uses 'docker exec'. For Fly.io, it uses 'flyctl ssh console' or direct SSH. For DevPod, it uses 'devpod ssh'. You land in the workspace directory as the 'developer' user with full environment access.",
      "tags": ["connect", "ssh", "access"],
      "docs": ["docs/CLI.md"]
    },
    {
      "id": "destroy-environment",
      "category": "deployment",
      "question": "How do I tear down a deployment?",
      "answer": "Run 'sindri destroy' for interactive confirmation or 'sindri destroy --force' to skip confirmation. This stops containers, destroys Fly.io machines and volumes, or removes DevPod workspaces. Warning: This is destructive and removes persistent data. Back up your workspace first if needed.",
      "tags": ["destroy", "teardown", "cleanup"],
      "docs": ["docs/CLI.md", "docs/DEPLOYMENT.md"]
    },
    {
      "id": "extension-install",
      "category": "extensions",
      "question": "How do I install an extension?",
      "answer": "Inside the deployed container, run 'extension-manager install <name>' (e.g., 'extension-manager install nodejs'). Dependencies are automatically resolved and installed in topological order. After installation, run 'source ~/.bashrc' to reload your environment, or reconnect to the container.",
      "tags": ["install", "extensions", "tools"],
      "docs": ["docs/EXTENSIONS.md", "docs/CLI.md"]
    },
    {
      "id": "extension-install-profile",
      "category": "extensions",
      "question": "How do I install all extensions from a profile?",
      "answer": "Run 'extension-manager install-profile <name>' (e.g., 'extension-manager install-profile fullstack'). This installs all extensions defined in the profile with their dependencies. Available profiles: minimal, fullstack, ai-dev, anthropic-dev, systems, enterprise, data-science, devops, mobile.",
      "tags": ["profile", "bundle", "install"],
      "docs": ["docs/EXTENSIONS.md"]
    },
    {
      "id": "extension-list",
      "category": "extensions",
      "question": "How do I see available extensions?",
      "answer": "Run 'extension-manager list' to see all available extensions. Use '--category <name>' to filter by category (language, dev-tools, ai, infrastructure, etc.). Run 'extension-manager list-profiles' to see available profiles, and 'extension-manager list-categories' to see all categories.",
      "tags": ["list", "available", "catalog"],
      "docs": ["docs/EXTENSIONS.md", "docs/CLI.md"]
    },
    {
      "id": "extension-validate",
      "category": "extensions",
      "question": "How do I validate that extensions are installed correctly?",
      "answer": "Run 'extension-manager validate <name>' for a single extension or 'extension-manager validate-all' for all installed extensions. Validation runs the extension's defined validation commands and checks expected output patterns. This verifies that tools are properly installed and accessible in PATH.",
      "tags": ["validate", "verify", "check"],
      "docs": ["docs/CLI.md"]
    },
    {
      "id": "extension-remove",
      "category": "extensions",
      "question": "How do I remove an extension?",
      "answer": "Run 'extension-manager remove <name>'. This executes the extension's removal script, updates the manifest, and cleans up installation artifacts. Some extensions (docker, infra-tools, etc.) require confirmation before removal. Note: Dependent extensions are not automatically removed.",
      "tags": ["remove", "uninstall", "delete"],
      "docs": ["docs/CLI.md"]
    },
    {
      "id": "extension-manager-where",
      "category": "extensions",
      "question": "Can I run extension-manager on my host machine or only inside the container?",
      "answer": "Extension-manager is designed for dual-environment execution. The primary use case is inside the deployed container where tools are actually installed. However, read-only operations like list, validate, info, and search work on the host machine too. For actual installations, run extension-manager inside the container since tools are installed to the persistent volume.",
      "tags": ["host", "container", "location"],
      "docs": ["docs/CLI.md", "docs/ARCHITECTURE.md"]
    },
    {
      "id": "extension-dependencies",
      "category": "extensions",
      "question": "How are extension dependencies handled?",
      "answer": "Dependencies are declared in each extension's YAML file and automatically resolved using topological sort. When you install an extension, all its dependencies are installed first. For example, ai-toolkit depends on nodejs, python, golang, and github-cli, which are all installed automatically. View dependencies with 'extension-manager info <name>'.",
      "tags": ["dependencies", "resolution", "automatic"],
      "docs": ["docs/EXTENSIONS.md", "docs/EXTENSION_AUTHORING.md"]
    },
    {
      "id": "create-extension",
      "category": "extensions",
      "question": "How do I create a custom extension?",
      "answer": "Create a directory in docker/lib/extensions/<name>/ with an extension.yaml file. Define metadata (name, version, category), requirements (domains, diskSpace), install method (mise, apt, script, binary, npm, or hybrid), configure section for environment variables, and validate section with verification commands. Add it to docker/lib/registry.yaml and validate with 'extension-manager validate <name>'.",
      "tags": ["create", "custom", "authoring"],
      "docs": ["docs/EXTENSION_AUTHORING.md"]
    },
    {
      "id": "secrets-overview",
      "category": "secrets",
      "question": "How does Sindri handle secrets?",
      "answer": "Sindri provides a unified, declarative secrets management approach. Secrets can come from three sources: env (environment variables, .env files), file (certificates, SSH keys mounted into container), or vault (HashiCorp Vault). Configure secrets in sindri.yaml under the 'secrets' section. Each provider handles secrets using its native mechanisms.",
      "tags": ["secrets", "overview", "management"],
      "docs": ["docs/SECRETS_MANAGEMENT.md"]
    },
    {
      "id": "secrets-env",
      "category": "secrets",
      "question": "How do I use environment variables for secrets?",
      "answer": "Create a .env.local file (gitignored) with your secrets like ANTHROPIC_API_KEY=sk-ant-.... In sindri.yaml, add: secrets: [{name: ANTHROPIC_API_KEY, source: env}]. Sindri resolves secrets in priority order: shell environment, .env.local, .env, then fromFile if specified. Mark secrets as 'required: true' to fail deployment if missing.",
      "tags": ["env", "environment", "dotenv"],
      "docs": ["docs/SECRETS_MANAGEMENT.md"]
    },
    {
      "id": "secrets-ssh",
      "category": "secrets",
      "question": "How do I configure SSH keys for container access?",
      "answer": "For SSH INTO the container, use 'fromFile' to read your public key: secrets: [{name: AUTHORIZED_KEYS, source: env, fromFile: ~/.ssh/id_ed25519.pub}]. Your laptop keeps the private key; the container gets the public key. For SSH OUT FROM the container (git clone), mount a deploy private key using source: file with appropriate mountPath and permissions: '0600'.",
      "tags": ["ssh", "keys", "authentication"],
      "docs": ["docs/SECRETS_MANAGEMENT.md"]
    },
    {
      "id": "secrets-vault",
      "category": "secrets",
      "question": "How do I integrate with HashiCorp Vault?",
      "answer": "Install Vault CLI and configure VAULT_ADDR and VAULT_TOKEN environment variables. In sindri.yaml, use: secrets: [{name: DATABASE_PASSWORD, source: vault, vaultPath: secret/data/myapp/prod, vaultKey: password}]. Sindri retrieves the secret at deploy time and injects it using the provider's native mechanism. Use 'sindri secrets test-vault' to verify connectivity.",
      "tags": ["vault", "hashicorp", "enterprise"],
      "docs": ["docs/SECRETS_MANAGEMENT.md"]
    },
    {
      "id": "secrets-validate",
      "category": "secrets",
      "question": "How do I validate my secrets configuration?",
      "answer": "Run 'sindri secrets validate' to check all configured secrets. It verifies that env secrets exist in .env files or environment, file secrets exist at specified paths, and vault secrets are retrievable. Output shows status for each secret with helpful hints for missing ones.",
      "tags": ["validate", "check", "verify"],
      "docs": ["docs/SECRETS_MANAGEMENT.md", "docs/CLI.md"]
    },
    {
      "id": "secrets-fly",
      "category": "secrets",
      "question": "How are secrets handled on Fly.io specifically?",
      "answer": "Sindri resolves secrets from configured sources, then runs 'flyctl secrets import' to set them atomically. File secrets are base64-encoded and decoded in the container entrypoint. You can also set secrets manually with 'flyctl secrets set KEY=value -a app-name'. Secrets persist across deployments and machine restarts.",
      "tags": ["fly", "flyctl", "cloud"],
      "docs": ["docs/SECRETS_MANAGEMENT.md", "docs/providers/FLY.md"]
    },
    {
      "id": "troubleshoot-yq",
      "category": "troubleshooting",
      "question": "I get 'yq command not found'. How do I fix this?",
      "answer": "Install yq: on macOS use 'brew install yq', on Ubuntu/Debian use 'sudo apt install yq', or manually download from GitHub releases and place in /usr/local/bin. Sindri uses yq for YAML processing. Verify installation with 'yq --version'.",
      "tags": ["yq", "install", "missing"],
      "docs": ["docs/TROUBLESHOOTING.md"]
    },
    {
      "id": "troubleshoot-docker",
      "category": "troubleshooting",
      "question": "I get 'Cannot connect to Docker daemon'. What's wrong?",
      "answer": "Docker isn't running. On macOS, open Docker Desktop application. On Linux, run 'sudo systemctl start docker'. If you get permission errors, add your user to the docker group: 'sudo usermod -aG docker $USER' then logout/login or run 'newgrp docker'.",
      "tags": ["docker", "daemon", "permission"],
      "docs": ["docs/TROUBLESHOOTING.md"]
    },
    {
      "id": "troubleshoot-extension",
      "category": "troubleshooting",
      "question": "An extension installation failed. How do I debug it?",
      "answer": "Check the installation log at /workspace/.system/logs/<extension>-install.log. Run 'extension-manager validate <extension>' to see what's failing. Common causes: insufficient disk space (check with 'df -h /workspace'), missing dependencies (run 'extension-manager show <extension>'), or network issues (test DNS with 'ping registry.npmjs.org').",
      "tags": ["extension", "failed", "debug", "logs"],
      "docs": ["docs/TROUBLESHOOTING.md"]
    },
    {
      "id": "troubleshoot-command-not-found",
      "category": "troubleshooting",
      "question": "After installing an extension, the command is not found. Why?",
      "answer": "Your shell environment needs to be reloaded. Run 'source ~/.bashrc' to reload PATH and environment variables. Alternatively, disconnect and reconnect to the container. For mise-managed tools, ensure mise is activated with 'eval \"$(mise activate bash)\"'. You can also run 'mise reshim' to regenerate shims.",
      "tags": ["path", "command", "bashrc", "reload"],
      "docs": ["docs/TROUBLESHOOTING.md"]
    },
    {
      "id": "troubleshoot-ssh-refused",
      "category": "troubleshooting",
      "question": "SSH connection refused on Fly.io. What should I check?",
      "answer": "The machine might be suspended (auto-stop). Check status with 'flyctl status -a <app>' and 'flyctl machine list -a <app>'. If suspended, either wait for auto-start on connection attempt (10-20 seconds) or manually start with 'flyctl machine start <machine-id> -a <app>'. Also verify your SSH key is authorized.",
      "tags": ["ssh", "fly", "connection", "refused"],
      "docs": ["docs/TROUBLESHOOTING.md", "docs/providers/FLY.md"]
    },
    {
      "id": "troubleshoot-permission-denied",
      "category": "troubleshooting",
      "question": "I get 'Permission denied' in /workspace. How do I fix it?",
      "answer": "The workspace should be owned by the 'developer' user (uid 1001). Check ownership with 'ls -la /workspace'. Fix with 'chown -R developer:developer /workspace' (run as root in container). This can happen if the volume was created with wrong permissions. Rebuilding the volume also fixes this.",
      "tags": ["permission", "ownership", "workspace"],
      "docs": ["docs/TROUBLESHOOTING.md"]
    },
    {
      "id": "troubleshoot-out-of-memory",
      "category": "troubleshooting",
      "question": "My container keeps getting killed (OOM). What do I do?",
      "answer": "Increase memory in sindri.yaml under deployment.resources.memory (e.g., from '2GB' to '4GB'). Then redeploy with 'sindri deploy'. Monitor usage with 'free -h' or 'docker stats'. For Fly.io, larger memory tiers use bigger VM sizes. Consider using the 'minimal' profile if running many tools isn't needed.",
      "tags": ["oom", "memory", "killed", "resources"],
      "docs": ["docs/TROUBLESHOOTING.md", "docs/CONFIGURATION.md"]
    },
    {
      "id": "architecture-volumes",
      "category": "architecture",
      "question": "How does Sindri's volume architecture work?",
      "answer": "Sindri uses a two-tier filesystem. Immutable system files in /docker/lib are baked into the image (extensions, schemas, scripts). The mutable home directory at /alt/home/developer is a persistent volume mount that IS $HOME. It contains workspace/, .local/, .config/, .cache/, and all user data. This survives container restarts and contains all installed tools.",
      "tags": ["volumes", "filesystem", "persistence", "home"],
      "docs": ["docs/ARCHITECTURE.md", "CLAUDE.md"]
    },
    {
      "id": "architecture-home",
      "category": "architecture",
      "question": "Why is $HOME at /alt/home/developer instead of /home/developer?",
      "answer": "The /alt/home/developer path is the persistent volume mount point. By making this $HOME, everything the user creates (configs, tools, projects) persists across container restarts. The 'alt' prefix avoids conflicts with the default /home directory that might be created by the base image. This is a key design decision for data persistence.",
      "tags": ["home", "path", "persistence"],
      "docs": ["docs/ARCHITECTURE.md", "CLAUDE.md"]
    },
    {
      "id": "architecture-entrypoint",
      "category": "architecture",
      "question": "What happens when the container starts (entrypoint)?",
      "answer": "The entrypoint.sh script runs as root and: initializes the home directory structure on first boot, sets correct ownership for the developer user, configures SSH authorized keys from AUTHORIZED_KEYS env var, configures Git user from GIT_USER_NAME and GIT_USER_EMAIL, then starts the SSH daemon on port 2222 (unless CI_MODE=true, which uses 'sleep infinity' instead).",
      "tags": ["entrypoint", "startup", "initialization"],
      "docs": ["docs/ARCHITECTURE.md", "docker/scripts/entrypoint.sh"]
    },
    {
      "id": "architecture-mise",
      "category": "architecture",
      "question": "What is mise and why does Sindri use it?",
      "answer": "Mise (formerly rtx) is a unified tool version manager that replaces asdf, nvm, pyenv, etc. Sindri uses mise because it's fast, supports many tools, and stores everything in the user's home directory (persistent volume). Tools installed via mise go to $HOME/.local/share/mise/, making them persist across container restarts. Extensions declare mise.toml configurations for tool installation.",
      "tags": ["mise", "tools", "version-manager"],
      "docs": ["docs/extensions/MISE-CONFIG.md", "docs/ARCHITECTURE.md"]
    },
    {
      "id": "architecture-adapters",
      "category": "architecture",
      "question": "How do provider adapters work?",
      "answer": "Each provider has a dedicated adapter script in deploy/adapters/ that handles the full lifecycle: deploy, connect, destroy, plan, status. The sindri CLI delegates all operations to these adapters. Docker adapter generates docker-compose.yml, Fly adapter generates fly.toml, DevPod adapter generates devcontainer.json. This keeps provider-specific logic encapsulated and makes adding new providers straightforward.",
      "tags": ["adapters", "providers", "architecture"],
      "docs": ["docs/ARCHITECTURE.md", "deploy/adapters/"]
    },
    {
      "id": "architecture-extensions-yaml",
      "category": "architecture",
      "question": "Why are extensions YAML files instead of bash scripts?",
      "answer": "YAML-first architecture is a core design principle. Extension definitions are declarative YAML that describe what to install, not how. The executor.sh module interprets the YAML and executes installation. This enables validation against JSON schemas, consistent behavior across extensions, easier maintenance, and the ability to add new installation methods without modifying extension files.",
      "tags": ["yaml", "declarative", "extensions"],
      "docs": ["docs/ARCHITECTURE.md", "docs/EXTENSION_AUTHORING.md"]
    },
    {
      "id": "cicd-local-testing",
      "category": "cicd",
      "question": "How do I run tests locally before pushing?",
      "answer": "Run tests inside a local container using sindri-test.sh. First build the image with 'pnpm build', then start a container with 'docker run -d --name test -e SKIP_AUTO_INSTALL=true sindri:local'. Run quick tests with 'docker exec test /docker/scripts/sindri-test.sh --level quick', extension tests with '--level extension', or profile tests with '--level profile --profile minimal'. This is the same test script used in CI.",
      "tags": ["testing", "local", "docker", "sindri-test"],
      "docs": ["docs/CI_WORKFLOW_IN_DEPTH.md", "docs/TESTING.md"]
    },
    {
      "id": "cicd-workflows-overview",
      "category": "cicd",
      "question": "What GitHub Actions workflows are available?",
      "answer": "Five main workflows: ci.yml (full CI pipeline - runs on push/PR), test-extensions.yml (test individual extensions from registry), test-profiles.yml (test sindri.yaml configs from examples/), manual-deploy.yml (deploy to any provider on-demand), and deploy-sindri.yml (reusable deployment workflow). Each can be triggered manually via GitHub UI or 'gh workflow run'.",
      "tags": ["workflows", "github", "actions", "overview"],
      "docs": [".github/workflows/", "docs/CI_WORKFLOW_IN_DEPTH.md"]
    },
    {
      "id": "cicd-trigger-workflows",
      "category": "cicd",
      "question": "How do I trigger CI workflows manually with gh CLI?",
      "answer": "Use 'gh workflow run <workflow>.yml' with field flags. Examples: 'gh workflow run ci.yml -f providers=\"docker,fly\" -f test-level=\"quick\"' for quick CI, 'gh workflow run test-extensions.yml -f extensions=\"nodejs,python\"' to test extensions, 'gh workflow run test-profiles.yml -f config-path=\"examples/fly/\"' to test configs. Add '-f skip-cleanup=true' for debugging.",
      "tags": ["gh", "cli", "trigger", "workflow"],
      "docs": ["docs/CI_WORKFLOW_IN_DEPTH.md"]
    },
    {
      "id": "cicd-test-levels",
      "category": "cicd",
      "question": "What are the different test levels in CI?",
      "answer": "Three test levels: 'quick' (10-15s) validates CLI commands work (sindri --version, extension-manager list); 'extension' (45-60s) tests full extension lifecycle (install, validate, remove) with idempotency check; 'profile' (90-120s) tests full profile lifecycle (install-profile, validate-all, remove). All tests run inside the container via /docker/scripts/sindri-test.sh.",
      "tags": ["testing", "levels", "quick", "extension", "profile"],
      "docs": ["docs/CI_WORKFLOW_IN_DEPTH.md"]
    },
    {
      "id": "cicd-ci-mode",
      "category": "cicd",
      "question": "What is CI_MODE and when should I use it?",
      "answer": "CI_MODE=true disables the SSH daemon and keeps the container alive with 'sleep infinity'. This avoids port conflicts with Fly.io's hallpass (port 22) and is designed for automated testing. CI mode also forces autoInstall=false for clean-slate testing. Access containers via 'flyctl ssh console' (Fly.io) or 'docker exec' (Docker) instead of direct SSH.",
      "tags": ["ci", "mode", "testing", "automated"],
      "docs": ["docs/CI_WORKFLOW_IN_DEPTH.md", "CLAUDE.md"]
    },
    {
      "id": "cicd-validation",
      "category": "cicd",
      "question": "How do I validate YAML and shell scripts?",
      "answer": "Run 'pnpm validate' to run all validation (YAML, shell, markdown). Individual commands: 'pnpm lint:yaml' (yamllint --strict), 'pnpm lint:shell' (shellcheck -S warning), 'pnpm lint:md' (markdownlint). The CI workflow (ci.yml) runs these checks automatically on push/PR. Schema validation happens via validate-yaml.yml workflow.",
      "tags": ["validation", "lint", "yaml", "shell"],
      "docs": [".github/workflows/validate-yaml.yml", "CLAUDE.md"]
    },
    {
      "id": "cicd-debug-failures",
      "category": "cicd",
      "question": "How do I debug CI test failures?",
      "answer": "Add '-f skip-cleanup=true' when triggering workflows to keep containers running after failure. Use 'gh run view <run-id> --log' to see logs. For Fly.io, SSH in with 'flyctl ssh console -a <app-name>'. Check extension logs at /alt/home/developer/workspace/.system/logs/<extension>-install.log. Use 'gh run watch' to monitor running workflows.",
      "tags": ["debug", "failures", "logs", "troubleshooting"],
      "docs": ["docs/CI_WORKFLOW_IN_DEPTH.md", "docs/TROUBLESHOOTING.md"]
    }
  ]
}
