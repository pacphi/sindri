#!/usr/bin/env bash
# mocks.bash - London School TDD Mock Library for Bash
#
# Provides command-level mocking with call recording and verification.
# Mocked commands are placed on PATH ahead of real commands, capturing
# all invocations for later assertion.
#
# Usage:
#   source tests/adapters/helpers/mocks.bash
#
#   setup_mock_environment    # call in setup()
#   mock_command "runpodctl" '{"id":"pod-123"}'
#   ... run code under test ...
#   verify_mock_called "runpodctl" "create pods --name test"
#   cleanup_mocks             # call in teardown()

# Directory where mock scripts and call logs are stored
MOCK_BIN_DIR=""
MOCK_LOG_DIR=""

# ─── Environment Setup / Teardown ─────────────────────────────────────────────

# Sets up a temporary directory for mock scripts and prepends it to PATH
# so mocked commands are found before real ones.
setup_mock_environment() {
    MOCK_BIN_DIR="$(mktemp -d "${BATS_TMPDIR:-/tmp}/mock-bin.XXXXXX")"
    MOCK_LOG_DIR="$(mktemp -d "${BATS_TMPDIR:-/tmp}/mock-log.XXXXXX")"
    export MOCK_BIN_DIR MOCK_LOG_DIR
    export PATH="${MOCK_BIN_DIR}:${PATH}"
}

# Removes all mock scripts and call logs.
cleanup_mocks() {
    if [[ -n "${MOCK_BIN_DIR:-}" && -d "${MOCK_BIN_DIR}" ]]; then
        rm -rf "${MOCK_BIN_DIR}"
    fi
    if [[ -n "${MOCK_LOG_DIR:-}" && -d "${MOCK_LOG_DIR}" ]]; then
        rm -rf "${MOCK_LOG_DIR}"
    fi
    MOCK_BIN_DIR=""
    MOCK_LOG_DIR=""
}

# ─── Mock Creation ────────────────────────────────────────────────────────────

# mock_command <command_name> [stdout_output] [exit_code]
#
# Creates a mock executable on the mock PATH. When invoked, the mock will:
#   1. Log the full command and arguments to MOCK_LOG_DIR/<command_name>.calls
#   2. Print stdout_output (default: empty)
#   3. Exit with exit_code (default: 0)
#
# Examples:
#   mock_command "runpodctl" '{"id":"pod-123"}' 0
#   mock_command "docker" "sha256:abc123"
#   mock_command "yq" "my-app-name"
#   mock_command "northflank" "" 1   # simulate failure
mock_command() {
    local cmd_name="$1"
    local stdout_output="${2:-}"
    local exit_code="${3:-0}"
    local mock_script="${MOCK_BIN_DIR}/${cmd_name}"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"

    cat > "${mock_script}" <<MOCK_SCRIPT
#!/usr/bin/env bash
# Mock for: ${cmd_name}
# Auto-generated by mocks.bash — do not edit

# Record the call with all arguments
echo "\$0 \$*" >> "${call_log}"

# Return configured output
cat <<'MOCK_OUTPUT'
${stdout_output}
MOCK_OUTPUT

exit ${exit_code}
MOCK_SCRIPT

    chmod +x "${mock_script}"
}

# mock_command_with_args <command_name> <args_pattern> <stdout_output> [exit_code]
#
# Creates a conditional mock that returns different output based on arguments.
# Appends a new condition to an existing mock (or creates one).
# If no pattern matches, the mock outputs nothing and exits 0.
#
# The args_pattern is matched as a grep extended regex against "$*".
#
# Examples:
#   mock_command_with_args "runpodctl" "create pods" '{"id":"pod-123"}' 0
#   mock_command_with_args "runpodctl" "get pod"     '{"status":"RUNNING"}' 0
#   mock_command_with_args "runpodctl" "remove pod"  "removed" 0
mock_command_with_args() {
    local cmd_name="$1"
    local args_pattern="$2"
    local stdout_output="$3"
    local exit_code="${4:-0}"
    local mock_script="${MOCK_BIN_DIR}/${cmd_name}"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"
    local conditions_file="${MOCK_LOG_DIR}/${cmd_name}.conditions"

    # Store the condition
    local condition_id
    condition_id=$(wc -l < "${conditions_file}" 2>/dev/null || echo "0")
    condition_id=$((condition_id + 1))

    local output_file="${MOCK_LOG_DIR}/${cmd_name}.output.${condition_id}"
    printf '%s' "${stdout_output}" > "${output_file}"
    echo "${args_pattern}|${exit_code}|${output_file}" >> "${conditions_file}"

    # (Re)generate the mock script with all conditions
    cat > "${mock_script}" <<'MOCK_HEADER'
#!/usr/bin/env bash
# Conditional mock — auto-generated by mocks.bash
MOCK_HEADER

    cat >> "${mock_script}" <<MOCK_LOGGING
echo "\$0 \$*" >> "${call_log}"
MOCK_LOGGING

    cat >> "${mock_script}" <<'MOCK_MATCHER'
all_args="$*"
MOCK_MATCHER

    # Read all conditions and generate if/elif chain
    local first=true
    while IFS='|' read -r pattern ecode ofile; do
        if $first; then
            echo "if echo \"\${all_args}\" | grep -qE '${pattern}'; then" >> "${mock_script}"
            first=false
        else
            echo "elif echo \"\${all_args}\" | grep -qE '${pattern}'; then" >> "${mock_script}"
        fi
        echo "  cat '${ofile}'" >> "${mock_script}"
        echo "  exit ${ecode}" >> "${mock_script}"
    done < "${conditions_file}"

    if ! $first; then
        cat >> "${mock_script}" <<'MOCK_FALLBACK'
else
  exit 0
fi
MOCK_FALLBACK
    fi

    chmod +x "${mock_script}"
}

# mock_command_with_callback <command_name> <callback_function>
#
# Creates a mock that delegates to a bash function. The function receives
# all arguments and its stdout/exit code become the mock's output.
#
# Example:
#   my_yq_mock() {
#       case "$2" in
#           '.name')          echo "my-app" ;;
#           '.provider.name') echo "runpod" ;;
#           *)                echo "unknown" ;;
#       esac
#   }
#   mock_command_with_callback "yq" "my_yq_mock"
mock_command_with_callback() {
    local cmd_name="$1"
    local callback_name="$2"
    local mock_script="${MOCK_BIN_DIR}/${cmd_name}"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"
    local callback_file="${MOCK_LOG_DIR}/${cmd_name}.callback.bash"

    # Export the callback function body so the mock can source it
    declare -f "${callback_name}" > "${callback_file}"

    cat > "${mock_script}" <<MOCK_SCRIPT
#!/usr/bin/env bash
echo "\$0 \$*" >> "${call_log}"
source "${callback_file}"
${callback_name} "\$@"
MOCK_SCRIPT

    chmod +x "${mock_script}"
}

# ─── Mock Verification ────────────────────────────────────────────────────────

# get_mock_call_count <command_name>
#
# Returns the number of times the mock was invoked.
get_mock_call_count() {
    local cmd_name="$1"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"
    if [[ -f "${call_log}" ]]; then
        wc -l < "${call_log}"
    else
        echo "0"
    fi
}

# get_mock_calls <command_name>
#
# Prints all recorded calls (one per line) for inspection.
get_mock_calls() {
    local cmd_name="$1"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"
    if [[ -f "${call_log}" ]]; then
        cat "${call_log}"
    fi
}

# get_mock_call <command_name> <call_number>
#
# Returns the Nth call (1-based index).
get_mock_call() {
    local cmd_name="$1"
    local call_number="$2"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"
    if [[ -f "${call_log}" ]]; then
        sed -n "${call_number}p" "${call_log}"
    fi
}

# verify_mock_called <command_name> [args_substring]
#
# Asserts that the mock was called at least once. If args_substring is
# provided, asserts that at least one call contained that substring.
# Returns 0 on success, 1 on failure (with diagnostic output).
verify_mock_called() {
    local cmd_name="$1"
    local args_substring="${2:-}"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"

    if [[ ! -f "${call_log}" ]]; then
        echo "FAIL: '${cmd_name}' was never called"
        return 1
    fi

    if [[ -z "${args_substring}" ]]; then
        return 0
    fi

    if grep -qF "${args_substring}" "${call_log}"; then
        return 0
    else
        echo "FAIL: '${cmd_name}' was called, but never with args containing '${args_substring}'"
        echo "Actual calls:"
        cat "${call_log}" | sed 's/^/  /'
        return 1
    fi
}

# verify_mock_not_called <command_name> [args_substring]
#
# Asserts that the mock was NOT called (or not called with given args).
verify_mock_not_called() {
    local cmd_name="$1"
    local args_substring="${2:-}"
    local call_log="${MOCK_LOG_DIR}/${cmd_name}.calls"

    if [[ ! -f "${call_log}" ]]; then
        return 0
    fi

    if [[ -z "${args_substring}" ]]; then
        echo "FAIL: '${cmd_name}' was called but should not have been"
        echo "Actual calls:"
        cat "${call_log}" | sed 's/^/  /'
        return 1
    fi

    if grep -qF "${args_substring}" "${call_log}"; then
        echo "FAIL: '${cmd_name}' was called with args containing '${args_substring}' but should not have been"
        return 1
    fi

    return 0
}

# verify_mock_call_count <command_name> <expected_count>
#
# Asserts the mock was called exactly N times.
verify_mock_call_count() {
    local cmd_name="$1"
    local expected="$2"
    local actual
    actual=$(get_mock_call_count "${cmd_name}")

    if [[ "${actual}" -eq "${expected}" ]]; then
        return 0
    else
        echo "FAIL: '${cmd_name}' was called ${actual} time(s), expected ${expected}"
        if [[ -f "${MOCK_LOG_DIR}/${cmd_name}.calls" ]]; then
            echo "Actual calls:"
            cat "${MOCK_LOG_DIR}/${cmd_name}.calls" | sed 's/^/  /'
        fi
        return 1
    fi
}

# verify_mock_call_order <command1> <command2>
#
# Asserts that command1 was called before command2 (by comparing
# the timestamp of their first call log entry).
verify_mock_call_order() {
    local first_cmd="$1"
    local second_cmd="$2"
    local log1="${MOCK_LOG_DIR}/${first_cmd}.calls"
    local log2="${MOCK_LOG_DIR}/${second_cmd}.calls"

    if [[ ! -f "${log1}" ]]; then
        echo "FAIL: '${first_cmd}' was never called"
        return 1
    fi
    if [[ ! -f "${log2}" ]]; then
        echo "FAIL: '${second_cmd}' was never called"
        return 1
    fi

    # Use file modification time as a rough proxy.
    # For precise ordering, we use a global sequence log.
    local seq_log="${MOCK_LOG_DIR}/_call_sequence.log"
    if [[ -f "${seq_log}" ]]; then
        local pos1 pos2
        pos1=$(grep -n "${first_cmd}" "${seq_log}" | head -1 | cut -d: -f1)
        pos2=$(grep -n "${second_cmd}" "${seq_log}" | head -1 | cut -d: -f1)
        if [[ -n "${pos1}" && -n "${pos2}" && "${pos1}" -lt "${pos2}" ]]; then
            return 0
        fi
    fi

    # Fallback: check file creation order (less reliable but works for simple cases)
    if [[ "${log1}" -ot "${log2}" ]] || [[ "${log1}" -ef "${log2}" ]]; then
        return 0
    fi

    echo "FAIL: '${first_cmd}' was not called before '${second_cmd}'"
    return 1
}

# ─── Convenience: Bulk Mocking ────────────────────────────────────────────────

# mock_all_external_commands
#
# Creates no-op mocks for all the external commands commonly used by
# Sindri adapters. Tests can override specific ones afterwards.
mock_all_external_commands() {
    mock_command "runpodctl" ""
    mock_command "northflank" ""
    mock_command "docker" ""
    mock_command "yq" ""
    mock_command "jq" ""
    mock_command "curl" ""
}
