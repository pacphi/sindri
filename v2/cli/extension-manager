#!/bin/bash
# extension-manager - Main entry point (fully declarative)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MODULES_DIR="$SCRIPT_DIR/extension-manager-modules"

# Source modules
source "$MODULES_DIR/cli.sh"
source "$MODULES_DIR/manifest.sh"
source "$MODULES_DIR/dependency.sh"
source "$MODULES_DIR/executor.sh"
source "$MODULES_DIR/validator.sh"
source "$MODULES_DIR/reporter.sh"
source "$MODULES_DIR/bom.sh"

# Main function
main() {
    # Parse global flags (modifies global vars directly, stores args in PARSED_ARGS)
    parse_args "$@"
    set -- "${PARSED_ARGS[@]}"

    local command="${1:-help}"
    shift || true

    case "$command" in
        list)
            if [[ -n "${FILTER_CATEGORY:-}" ]]; then
                list_extensions | grep -E "^  .* $FILTER_CATEGORY"
            else
                list_extensions
            fi
            ;;
        list-profiles)
            list_profiles
            ;;
        list-categories)
            list_categories
            ;;
        install)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager install <name>"
                return 1
            fi
            local ext_name="$1"

            # Security fix H-11: Rate limiting for individual installs (not profiles)
            # Profiles are exempt as they're intentional batch operations
            # Allow 10 individual install operations per 5 minutes
            if ! check_rate_limit "extension-install-single" 10 300; then
                print_status "Tip: Use 'install-profile' for batch installations (no rate limit)"
                return 1
            fi

            # Resolve dependencies first
            local resolved
            resolved=$(resolve_dependencies "$ext_name")
            # Install in dependency order
            for ext in $resolved; do
                # Get category from registry
                local category
                category=$(load_yaml "${DOCKER_LIB}/registry.yaml" ".extensions.\"$ext\".category" 2>/dev/null || echo "unknown")
                execute_extension "$ext" "install"
                add_to_manifest "$ext" "$category"
            done
            ;;
        install-profile)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager install-profile <profile>"
                return 1
            fi
            install_profile "$1"
            ;;
        install-all)
            local active_exts
            active_exts=$(get_active_extensions)
            if [[ -n "$active_exts" ]]; then
                # Resolve all dependencies
                local resolved
                # shellcheck disable=SC2086  # Word splitting intentional for multiple extensions
                resolved=$(resolve_dependencies $active_exts)
                # Install in order
                for ext in $resolved; do
                    execute_extension "$ext" "install"
                done
            else
                print_warning "No active extensions in manifest"
            fi
            ;;
        reinstall)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager reinstall <name>"
                return 1
            fi
            local ext_name="$1"
            print_header "Reinstalling extension: $ext_name"
            # Remove first (force mode to skip confirmation)
            FORCE_MODE=true execute_extension "$ext_name" "remove" 2>/dev/null || true
            remove_from_manifest "$ext_name" 2>/dev/null || true
            # Clear installed marker
            mark_uninstalled "$ext_name" 2>/dev/null || true
            # Resolve dependencies and install
            local resolved
            resolved=$(resolve_dependencies "$ext_name")
            for ext in $resolved; do
                local category
                category=$(load_yaml "${DOCKER_LIB}/registry.yaml" ".extensions.\"$ext\".category" 2>/dev/null || echo "unknown")
                execute_extension "$ext" "install"
                add_to_manifest "$ext" "$category"
            done
            ;;
        reinstall-profile)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager reinstall-profile <profile>"
                return 1
            fi
            reinstall_profile "$1"
            ;;
        remove)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager remove <name>"
                return 1
            fi

            # Security fix H-11: Rate limiting for individual removes
            # Allow 10 individual remove operations per 5 minutes
            if ! check_rate_limit "extension-remove-single" 10 300; then
                return 1
            fi

            execute_extension "$1" "remove"
            remove_from_manifest "$1"
            ;;
        validate)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager validate <name>"
                return 1
            fi
            execute_extension "$1" "validate"
            ;;
        validate-all)
            validate_all_extensions
            ;;
        validate-domains)
            if [[ $# -eq 0 ]]; then
                # Validate all extensions
                validate_all_domains
            else
                # Validate specific extension
                validate_extension_domains "$1"
            fi
            ;;
        status)
            if [[ $# -eq 0 ]]; then
                show_all_status
            else
                execute_extension "$1" "status"
            fi
            ;;
        resolve)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager resolve <name>"
                return 1
            fi
            local resolved
            resolved=$(resolve_dependencies "$1")
            echo "Dependency resolution order:"
            for ext in $resolved; do
                echo "  - $ext"
            done
            ;;
        search)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager search <term>"
                return 1
            fi
            search_extensions "$1"
            ;;
        info)
            if [[ $# -eq 0 ]]; then
                print_error "Usage: extension-manager info <name>"
                return 1
            fi
            show_extension_info "$1"
            ;;
        bom)
            show_bom "${1:-}"
            ;;
        bom-regenerate)
            regenerate_all_boms
            ;;
        mcp)
            # Source MCP manager
            if [[ -f "${DOCKER_LIB}/mcp-manager.sh" ]]; then
                source "${DOCKER_LIB}/mcp-manager.sh"
            else
                print_error "MCP manager not found"
                return 1
            fi

            local mcp_command="${1:-}"
            shift || true

            case "$mcp_command" in
                list)
                    list_mcp_extensions
                    ;;
                registered)
                    list_registered_mcp_servers
                    ;;
                register)
                    if [[ $# -eq 0 ]]; then
                        print_error "Usage: extension-manager mcp register <extension>"
                        return 1
                    fi
                    register_mcp_server "$1"
                    ;;
                unregister)
                    if [[ $# -eq 0 ]]; then
                        print_error "Usage: extension-manager mcp unregister <extension>"
                        return 1
                    fi
                    unregister_mcp_server "$1"
                    ;;
                show)
                    if [[ $# -eq 0 ]]; then
                        print_error "Usage: extension-manager mcp show <extension>"
                        return 1
                    fi
                    show_mcp_server_details "$1"
                    ;;
                *)
                    print_error "Unknown mcp command: $mcp_command"
                    echo ""
                    echo "Available mcp commands:"
                    echo "  list              List extensions with MCP capabilities"
                    echo "  registered        List registered MCP servers in Claude Code"
                    echo "  register <ext>    Register extension as MCP server"
                    echo "  unregister <ext>  Unregister extension from MCP servers"
                    echo "  show <ext>        Show MCP server details for extension"
                    return 1
                    ;;
            esac
            ;;
        help|-h|--help)
            show_help
            ;;
        *)
            print_error "Unknown command: $command"
            show_help
            return 1
            ;;
    esac
}

# Install profile (loads from declarative YAML)
install_profile() {
    local profile="$1"
    local profiles_file="${DOCKER_LIB}/profiles.yaml"

    if [[ ! -f "$profiles_file" ]]; then
        print_error "Profiles file not found"
        return 1
    fi

    # Check if profile exists
    local profile_exists
    profile_exists=$(load_yaml "$profiles_file" ".profiles.\"$profile\"" 2>/dev/null || echo "null")

    if [[ "$profile_exists" == "null" ]]; then
        print_error "Unknown profile: $profile"
        print_status "Available profiles:"
        load_yaml "$profiles_file" '.profiles | keys[]' 2>/dev/null | sed 's/^/  - /'
        return 1
    fi

    print_header "Installing profile: $profile"

    # Track installation results
    local failed_extensions=""
    local installed_count=0
    local failed_count=0

    # Install protected base extensions first
    # These are required for workspace structure and tool management
    local protected_exts
    protected_exts=$(load_yaml "${DOCKER_LIB}/registry.yaml" '.extensions | to_entries[] | select(.value.protected == true) | .key' 2>/dev/null || echo "mise-config")

    for base_ext in $protected_exts; do
        if ! is_extension_installed "$base_ext"; then
            print_status "Installing base extension: $base_ext"
            if execute_extension "$base_ext" "install"; then
                add_to_manifest "$base_ext" "base" true
                ((installed_count++)) || true
            else
                print_warning "Base extension failed: $base_ext (continuing...)"
                failed_extensions="${failed_extensions:+$failed_extensions, }$base_ext"
                ((failed_count++)) || true
            fi
        fi
    done

    # Get extensions from profile
    local extensions
    extensions=$(load_yaml "$profiles_file" ".profiles.\"$profile\".extensions[]" 2>/dev/null || echo "")

    if [[ -z "$extensions" ]]; then
        print_error "Profile has no extensions defined"
        return 1
    fi

    # Resolve dependencies for all extensions in profile
    local resolved
    # shellcheck disable=SC2086  # Word splitting intentional for multiple extensions
    resolved=$(resolve_dependencies $extensions)

    # Install in order, continuing on failures
    for ext in $resolved; do
        # Get category from registry
        local category
        category=$(load_yaml "${DOCKER_LIB}/registry.yaml" ".extensions.\"$ext\".category" 2>/dev/null || echo "unknown")

        if execute_extension "$ext" "install"; then
            add_to_manifest "$ext" "$category"
            ((installed_count++)) || true
        else
            print_warning "Extension failed: $ext (continuing with remaining extensions...)"
            failed_extensions="${failed_extensions:+$failed_extensions, }$ext"
            ((failed_count++)) || true
        fi
    done

    # Report results
    if [[ $failed_count -eq 0 ]]; then
        print_success "Installed profile: $profile ($installed_count extensions)"
    else
        print_warning "Profile $profile partially installed: $installed_count succeeded, $failed_count failed"
        print_warning "Failed extensions: $failed_extensions"
        return 1
    fi
}

# Reinstall profile (removes and reinstalls all extensions in profile)
reinstall_profile() {
    local profile="$1"
    local profiles_file="${DOCKER_LIB}/profiles.yaml"

    if [[ ! -f "$profiles_file" ]]; then
        print_error "Profiles file not found"
        return 1
    fi

    # Check if profile exists
    local profile_exists
    profile_exists=$(load_yaml "$profiles_file" ".profiles.\"$profile\"" 2>/dev/null || echo "null")

    if [[ "$profile_exists" == "null" ]]; then
        print_error "Unknown profile: $profile"
        print_status "Available profiles:"
        load_yaml "$profiles_file" '.profiles | keys[]' 2>/dev/null | sed 's/^/  - /'
        return 1
    fi

    print_header "Reinstalling profile: $profile"

    # Get extensions from profile
    local extensions
    extensions=$(load_yaml "$profiles_file" ".profiles.\"$profile\".extensions[]" 2>/dev/null || echo "")

    if [[ -z "$extensions" ]]; then
        print_error "Profile has no extensions defined"
        return 1
    fi

    # Resolve dependencies for all extensions in profile
    local resolved
    # shellcheck disable=SC2086  # Word splitting intentional for multiple extensions
    resolved=$(resolve_dependencies $extensions)

    # Remove all extensions first (in reverse order to handle dependencies)
    local reversed_exts
    reversed_exts=$(echo "$resolved" | tac)

    print_status "Removing existing extensions..."
    for ext in $reversed_exts; do
        if is_extension_installed "$ext"; then
            FORCE_MODE=true execute_extension "$ext" "remove" 2>/dev/null || true
            remove_from_manifest "$ext" 2>/dev/null || true
            mark_uninstalled "$ext" 2>/dev/null || true
        fi
    done

    # Track installation results
    local failed_extensions=""
    local installed_count=0
    local failed_count=0

    # Install protected base extensions first
    local protected_exts
    protected_exts=$(load_yaml "${DOCKER_LIB}/registry.yaml" '.extensions | to_entries[] | select(.value.protected == true) | .key' 2>/dev/null || echo "mise-config")

    for base_ext in $protected_exts; do
        print_status "Reinstalling base extension: $base_ext"
        # Remove first
        FORCE_MODE=true execute_extension "$base_ext" "remove" 2>/dev/null || true
        mark_uninstalled "$base_ext" 2>/dev/null || true
        # Install
        if execute_extension "$base_ext" "install"; then
            add_to_manifest "$base_ext" "base" true
            ((installed_count++)) || true
        else
            print_warning "Base extension failed: $base_ext (continuing...)"
            failed_extensions="${failed_extensions:+$failed_extensions, }$base_ext"
            ((failed_count++)) || true
        fi
    done

    # Install in dependency order
    print_status "Installing extensions..."
    for ext in $resolved; do
        local category
        category=$(load_yaml "${DOCKER_LIB}/registry.yaml" ".extensions.\"$ext\".category" 2>/dev/null || echo "unknown")

        if execute_extension "$ext" "install"; then
            add_to_manifest "$ext" "$category"
            ((installed_count++)) || true
        else
            print_warning "Extension failed: $ext (continuing with remaining extensions...)"
            failed_extensions="${failed_extensions:+$failed_extensions, }$ext"
            ((failed_count++)) || true
        fi
    done

    # Report results
    if [[ $failed_count -eq 0 ]]; then
        print_success "Reinstalled profile: $profile ($installed_count extensions)"
    else
        print_warning "Profile $profile partially reinstalled: $installed_count succeeded, $failed_count failed"
        print_warning "Failed extensions: $failed_extensions"
        return 1
    fi
}

# Initialize workspace if not already done
initialize_workspace() {
    local home_dir="${HOME:-/alt/home/developer}"
    local workspace="${WORKSPACE:-$home_dir/workspace}"

    if [[ ! -f "$home_dir/.initialized" ]]; then
        print_status "Initializing workspace..."

        # Create workspace directory structure
        ensure_directory "$workspace/projects"
        ensure_directory "$workspace/config"
        ensure_directory "$workspace/scripts"
        ensure_directory "$workspace/bin"
        ensure_directory "$workspace/.system"
        ensure_directory "$workspace/.system/manifest"
        ensure_directory "$workspace/.system/installed"
        ensure_directory "$workspace/.system/logs"

        # Create XDG directories in $HOME (not $WORKSPACE)
        ensure_directory "$home_dir/.local/share/mise"
        ensure_directory "$home_dir/.local/state/mise"
        ensure_directory "$home_dir/.local/bin"
        ensure_directory "$home_dir/.config/mise/conf.d"
        ensure_directory "$home_dir/.cache/mise"

        # Create essential files in $HOME (not $WORKSPACE)
        [[ ! -f "$home_dir/.bashrc" ]] && touch "$home_dir/.bashrc"
        [[ ! -f "$home_dir/.profile" ]] && touch "$home_dir/.profile"

        # Initialize manifest
        initialize_manifest

        touch "$home_dir/.initialized"
        print_success "Workspace initialized"
    fi
}

# Ensure workspace directories exist for critical operations
# This is a lighter check than full initialization
ensure_workspace_ready() {
    local home_dir="${HOME:-/alt/home/developer}"
    local workspace="${WORKSPACE:-$home_dir/workspace}"

    # Ensure critical workspace directories exist
    ensure_directory "$workspace/.system/manifest"
    ensure_directory "$workspace/.system/installed"

    # Ensure .bashrc exists in $HOME (needed for configure_extension)
    [[ ! -f "$home_dir/.bashrc" ]] && touch "$home_dir/.bashrc" 2>/dev/null || true
}

# Run full initialization if explicitly requested, otherwise ensure workspace is ready
if [[ "${INIT_WORKSPACE:-false}" == "true" ]]; then
    initialize_workspace
else
    # Always ensure critical workspace directories exist
    ensure_workspace_ready
fi

main "$@"
