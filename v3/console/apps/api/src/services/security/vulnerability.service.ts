/**
 * Vulnerability management service.
 *
 * Persists detected vulnerabilities, tracks status transitions,
 * and provides query APIs for the security dashboard.
 */

import { db } from "../../lib/db.js";
import { logger } from "../../lib/logger.js";
import type {
  DetectedVulnerability,
  VulnerabilitySeverity,
  SecuritySummary,
  SecurityScore,
} from "./types.js";

// ─────────────────────────────────────────────────────────────────────────────
// Write operations
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Persist a batch of detected vulnerabilities for an instance.
 * Uses upsert on (instance_id, cve_id, package_name, ecosystem) to avoid duplication.
 */
export async function saveVulnerabilities(
  instanceId: string,
  vulns: DetectedVulnerability[],
): Promise<number> {
  let saved = 0;
  for (const v of vulns) {
    try {
      // Check if already exists and is not OPEN
      const existing = await db.vulnerability.findFirst({
        where: {
          instance_id: instanceId,
          cve_id: v.cveId,
          package_name: v.packageName,
          ecosystem: v.ecosystem,
        },
        select: { id: true, status: true },
      });

      if (existing && existing.status !== "OPEN") {
        // Don't re-open acknowledged/fixed vulnerabilities
        continue;
      }

      if (existing) {
        await db.vulnerability.update({
          where: { id: existing.id },
          data: {
            cvss_score: v.cvssScore,
            severity: v.severity,
            title: v.title,
            description: v.description,
            fix_version: v.fixVersion,
            references: v.references,
            detected_at: new Date(),
          },
        });
      } else {
        await db.vulnerability.create({
          data: {
            instance_id: instanceId,
            cve_id: v.cveId,
            osv_id: v.osvId,
            package_name: v.packageName,
            package_version: v.packageVersion,
            ecosystem: v.ecosystem,
            severity: v.severity,
            cvss_score: v.cvssScore,
            title: v.title,
            description: v.description,
            fix_version: v.fixVersion,
            references: v.references,
          },
        });
      }
      saved++;
    } catch (err) {
      logger.warn({ err, instanceId, cveId: v.cveId }, "Failed to save vulnerability");
    }
  }
  return saved;
}

// ─────────────────────────────────────────────────────────────────────────────
// Status transitions
// ─────────────────────────────────────────────────────────────────────────────

export async function acknowledgeVulnerability(id: string, userId: string) {
  return db.vulnerability.update({
    where: { id },
    data: {
      status: "ACKNOWLEDGED",
      acknowledged_at: new Date(),
      acknowledged_by: userId,
    },
  });
}

export async function markVulnerabilityFixed(id: string) {
  return db.vulnerability.update({
    where: { id },
    data: { status: "FIXED", fixed_at: new Date() },
  });
}

export async function markFalsePositive(id: string) {
  return db.vulnerability.update({
    where: { id },
    data: { status: "FALSE_POSITIVE" },
  });
}

// ─────────────────────────────────────────────────────────────────────────────
// Query operations
// ─────────────────────────────────────────────────────────────────────────────

export interface VulnerabilityFilters {
  instanceId?: string;
  severity?: VulnerabilitySeverity;
  status?: string;
  ecosystem?: string;
}

export async function listVulnerabilities(filters: VulnerabilityFilters, page = 1, pageSize = 50) {
  const where = {
    ...(filters.instanceId ? { instance_id: filters.instanceId } : {}),
    ...(filters.severity ? { severity: filters.severity } : {}),
    ...(filters.status
      ? { status: filters.status as "OPEN" | "ACKNOWLEDGED" | "FIXED" | "FALSE_POSITIVE" }
      : {}),
    ...(filters.ecosystem ? { ecosystem: filters.ecosystem } : {}),
  };

  const [total, items] = await Promise.all([
    db.vulnerability.count({ where }),
    db.vulnerability.findMany({
      where,
      orderBy: [{ severity: "asc" }, { detected_at: "desc" }],
      skip: (page - 1) * pageSize,
      take: pageSize,
      include: { instance: { select: { name: true } } },
    }),
  ]);

  return {
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
    items: items.map((v) => ({
      id: v.id,
      instanceId: v.instance_id,
      instanceName: v.instance.name,
      cveId: v.cve_id,
      osvId: v.osv_id,
      packageName: v.package_name,
      packageVersion: v.package_version,
      ecosystem: v.ecosystem,
      severity: v.severity,
      cvssScore: v.cvss_score,
      title: v.title,
      description: v.description,
      fixVersion: v.fix_version,
      references: v.references,
      status: v.status,
      detectedAt: v.detected_at.toISOString(),
      acknowledgedAt: v.acknowledged_at?.toISOString(),
      fixedAt: v.fixed_at?.toISOString(),
    })),
  };
}

// ─────────────────────────────────────────────────────────────────────────────
// Security scoring
// ─────────────────────────────────────────────────────────────────────────────

function computeSecurityScore(
  vulnCounts: Record<VulnerabilitySeverity, number>,
  overdueSecrets: number,
  weakSshKeys: number,
): SecurityScore {
  // Vulnerability sub-score (0–60 points)
  const vulnPenalty =
    (vulnCounts.CRITICAL ?? 0) * 20 +
    (vulnCounts.HIGH ?? 0) * 10 +
    (vulnCounts.MEDIUM ?? 0) * 5 +
    (vulnCounts.LOW ?? 0) * 2;
  const vulnScore = Math.max(0, 60 - vulnPenalty);

  // Secret rotation sub-score (0–25 points)
  const secretPenalty = overdueSecrets * 5;
  const secretScore = Math.max(0, 25 - secretPenalty);

  // SSH key sub-score (0–15 points)
  const sshPenalty = weakSshKeys * 5;
  const sshScore = Math.max(0, 15 - sshPenalty);

  const total = Math.round(vulnScore + secretScore + sshScore);
  const grade = total >= 90 ? "A" : total >= 75 ? "B" : total >= 60 ? "C" : total >= 40 ? "D" : "F";

  return {
    total,
    breakdown: {
      vulnerabilities: Math.round(vulnScore),
      secretRotation: Math.round(secretScore),
      sshKeys: Math.round(sshScore),
    },
    grade,
  };
}

export async function getSecuritySummary(instanceId?: string): Promise<SecuritySummary> {
  const vulnWhere = {
    status: "OPEN" as const,
    ...(instanceId ? { instance_id: instanceId } : {}),
  };

  const [vulnGroups, acknowledgedCount, overdueSecrets, sshKeyStats] = await Promise.all([
    db.vulnerability.groupBy({
      by: ["severity"],
      where: vulnWhere,
      _count: { id: true },
    }),
    db.vulnerability.count({
      where: { status: "ACKNOWLEDGED", ...(instanceId ? { instance_id: instanceId } : {}) },
    }),
    db.secretRotation.count({
      where: { is_overdue: true, ...(instanceId ? { instance_id: instanceId } : {}) },
    }),
    db.sshKey.groupBy({
      by: ["status", "key_type", "key_bits"],
      where: instanceId ? { instance_id: instanceId } : {},
      _count: { id: true },
    }),
  ]);

  const bySeverity: Record<VulnerabilitySeverity, number> = {
    CRITICAL: 0,
    HIGH: 0,
    MEDIUM: 0,
    LOW: 0,
    UNKNOWN: 0,
  };
  let totalVulnerabilities = 0;
  for (const g of vulnGroups) {
    bySeverity[g.severity as VulnerabilitySeverity] = g._count.id;
    totalVulnerabilities += g._count.id;
  }

  const expiredSshKeys = sshKeyStats
    .filter((s) => s.status === "EXPIRED")
    .reduce((acc, s) => acc + s._count.id, 0);

  // Weak SSH keys: RSA < 2048 bits or DSA keys
  const weakSshKeys = sshKeyStats
    .filter(
      (s) =>
        s.status === "ACTIVE" &&
        (s.key_type === "dsa" || (s.key_type === "rsa" && (s.key_bits ?? 0) < 2048)),
    )
    .reduce((acc, s) => acc + s._count.id, 0);

  const securityScore = computeSecurityScore(bySeverity, overdueSecrets, weakSshKeys);

  return {
    totalVulnerabilities,
    bySeverity,
    openCount: totalVulnerabilities,
    acknowledgedCount,
    overdueSecrets,
    expiredSshKeys,
    weakSshKeys,
    securityScore,
  };
}
